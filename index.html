<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced English Typing Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Source+Code+Pro:wght@400;700&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Font Imports */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #e3f2fd; /* Light Blue background */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align at the top */
            min-height: 100vh;
            padding: 20px;
            background: linear-gradient(to right, #e3f2fd, #fce4ec); /* Light Blue to Light Pink Gradient */
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15); /* More prominent shadow */
            width: 100%;
            max-width: 900px;
            animation: fadeIn 0.8s ease-out;
            border: 1px solid #bbdefb; /* Light blue border */
            position: relative; /* For z-index to work with settings overlay */
            z-index: 1; /* Ensure container is above other elements when settings are hidden */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            text-align: center;
            color: #e91e63; /* Pink primary color */
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5em; /* Larger title */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }

        /* Live Stats Area (moved to top) */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px; /* Space below stats */
            flex-wrap: wrap;
            gap: 15px;
            background-color: #fce4ec; /* Light pink background */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }

        .stat-item {
            background-color: #fff;
            padding: 12px 18px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            text-align: center;
            min-width: 120px;
            flex: 1;
            border: 1px solid #f8bbd0; /* Slightly darker pink border */
        }

        .stat-item h3 {
            color: #6a1b9a; /* Deep purple for sub-headers */
            font-size: 1em;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .stat-item p {
            font-size: 1.8em; /* Slightly smaller for compactness */
            font-weight: bold;
            color: #e91e63; /* Pink for values */
            font-family: 'Montserrat', sans-serif;
        }

        .timer-item p {
            color: #2196f3; /* Blue for timer */
        }
        
        /* New: Live CPM display style */
        .cpm-item p {
            color: #ff9800; /* Orange for CPM */
        }

        /* Test Area */
        .test-area {
            margin-bottom: 20px; /* Reduced margin */
            padding: 20px;
            background-color: #f1f8e9; /* Very light green for contrast */
            border-radius: 10px;
            border: 1px solid #dcedc8;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            min-height: 120px; /* Smaller height */
            max-height: 120px; /* Fixed height for 3 lines */
            overflow: hidden; /* Hide overflow */
            position: relative;
            line-height: 1.8; /* More spacing for readability */
            font-size: 1.2em; /* Slightly smaller font for more words per line */
            font-family: 'Open Sans', sans-serif; /* Changed to Open Sans for better readability */
            color: #444;
        }

        /* For handling paragraphs and line breaks in test-area */
        .paragraph {
            margin-bottom: 1.5em; /* Space between paragraphs */
            white-space: pre-wrap; /* Preserves whitespace and wraps text */
        }

        .word {
            display: inline-block;
            margin-right: 5px;
            padding: 1px 0;
            white-space: pre-wrap; /* Ensure words don't break mid-char for spaces */
        }

        .current-word {
            background-color: #fff9c4; /* Light yellow for current word */
            border-radius: 4px;
            padding: 1px 5px;
            box-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
        }

        .correct {
            color: #388e3c; /* Dark green for correct */
        }

        .incorrect {
            color: #d32f2f; /* Dark red for incorrect */
            text-decoration: underline wavy #d32f2f 2px;
        }

        .extra {
            color: #7b7b7b;
            background-color: #ffebee; /* Very light red background for extra */
            border-radius: 3px;
            padding: 0 2px;
        }

        .untyped {
            color: #7b7b7b;
        }

        /* Input Area */
        #typing-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.5em;
            border: 2px solid #ccc;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Source Code Pro', monospace; /* Kept monospace for input */
            background-color: #fcfcfc;
            margin-bottom: 20px; /* Space below input */
        }

        #typing-input:focus {
            border-color: #2196f3; /* Blue on focus */
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
        }

        /* Controls */
        .controls {
            text-align: center;
            margin-top: 20px; /* Reduced margin */
        }

        .button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px; /* Slightly more rounded buttons */
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            margin: 0 10px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
        }

        .button.primary {
            background-color: #e91e63; /* Pink primary */
            color: white;
            box-shadow: 0 4px 8px rgba(233, 30, 99, 0.2);
        }

        .button.primary:hover {
            background-color: #d81b60; /* Darker pink on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(233, 30, 99, 0.3);
        }

        .button.secondary {
            background-color: #2196f3; /* Blue secondary */
            color: white;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.2);
        }

        .button.secondary:hover {
            background-color: #1976d2; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(33, 150, 243, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Result Modal */
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .result-modal.show {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            max-width: 600px; /* Wider modal */
            width: 90%;
            border: 1px solid #bbdefb;
        }

        .result-modal.show .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            color: #e91e63;
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2em;
        }

        .modal-content .stats {
            flex-wrap: wrap; /* Ensure wrapping in modal too */
            justify-content: center;
            margin-bottom: 20px;
        }

        .modal-content .stat-item {
            margin-bottom: 15px;
            background-color: #e3f2fd; /* Light blue in modal stats */
            border: 1px solid #90caf9;
        }

        /* Result Colors */
        .result-value-green {
            color: #388e3c; /* Green for good results (WPM, Accuracy) */
        }
        .result-value-red {
            color: #d32f2f; /* Red for bad results (Errors) */
        }
        .result-value-orange {
            color: #ff9800; /* Orange for CPM */
        }
        .result-value-purple {
            color: #6a1b9a; /* Purple for Raw WPM */
        }


        .modal-content .button {
            margin-top: 25px;
            margin: 10px; /* Space between modal buttons */
        }

        /* Target Status in Modal */
        .stat-item.target-status p {
            font-size: 1.5em; /* Smaller font for target status */
        }
        .status-neutral { color: #607d8b; } /* Grey */
        .status-met { color: #388e3c; } /* Green */
        .status-not-met { color: #d32f2f; } /* Red */

        /* Settings Overlay (Full-screen) */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker, more opaque background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher z-index than container and result modal */
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.4s ease;
        }

        .settings-overlay.show {
            visibility: visible;
            opacity: 1;
        }

        .settings-overlay .settings-content {
            background-color: #f0f4c3; /* Light yellow-green for settings */
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            border: 1px solid #cddc39;
            transform: scale(0.9);
            transition: transform 0.4s ease;

            /* Fix for overflow on settings screen */
            max-height: 90vh; /* Limit height to 90% of viewport height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }

        .settings-overlay.show .settings-content {
            transform: scale(1);
        }

        .settings-overlay h2 {
            color: #4CAF50; /* Green for settings header */
            margin-bottom: 30px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2em;
        }

        .setting-group {
            margin-bottom: 25px; /* More space between groups */
            text-align: left;
        }

        .setting-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px; /* More space below label */
            color: #388e3c; /* Darker green for setting labels */
            font-size: 1.15em;
        }

        .setting-group select,
        .setting-group input[type="number"] {
            width: 100%;
            padding: 12px; /* Larger padding for inputs */
            border: 1px solid #aed581; /* Greenish border */
            border-radius: 8px;
            font-size: 1.1em;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Roboto', sans-serif;
        }

        .setting-group select:focus,
        .setting-group input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        /* New: Custom Story Area styles */
        #custom-story-area {
            display: none; /* Hidden by default */
            margin-top: 20px;
            border-top: 1px solid #cddc39;
            padding-top: 20px;
        }

        #custom-story-textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid #aed581;
            border-radius: 8px;
            font-size: 1.1em;
            font-family: 'Open Sans', sans-serif;
            resize: vertical;
            margin-bottom: 10px;
        }

        #custom-story-textarea:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        .custom-story-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .custom-story-controls .button {
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 48%; /* Adjust for spacing */
        }
        
        @media (max-width: 480px) {
            .custom-story-controls .button {
                max-width: 100%; /* Stack buttons on very small screens */
            }
        }


        .settings-overlay .button-group {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        /* Initial hidden state for the main content */
        .content-hidden {
            visibility: hidden;
            opacity: 0;
            height: 0;
            overflow: hidden;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            .stats {
                gap: 10px;
            }

            .stat-item {
                min-width: 100px;
                padding: 10px 12px;
            }

            .stat-item p {
                font-size: 1.5em;
            }

            .test-area {
                font-size: 1.1em;
                padding: 15px;
                min-height: 100px;
                max-height: 100px;
            }

            #typing-input {
                font-size: 1.2em;
                padding: 10px 15px;
            }

            .button {
                padding: 10px 20px;
                font-size: 1em;
                margin: 5px;
            }

            .modal-content {
                padding: 25px;
            }

            .modal-content h2 {
                font-size: 1.8em;
            }

            .settings-overlay .settings-content {
                padding: 25px;
            }
            .settings-overlay h2 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            .setting-group {
                margin-bottom: 20px;
            }
            .settings-overlay .button-group {
                flex-direction: column;
                gap: 15px;
            }
            .settings-overlay .button {
                width: 80%; /* Make buttons wider on small screens */
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <div class="settings-overlay" id="settings-overlay">
        <div class="settings-content">
            <h2>Typing Test Settings</h2>
            <div class="setting-group">
                <label for="test-duration">Select Test Duration:</label>
                <select id="test-duration">
                    <option value="1">1 Minute</option>
                    <option value="2">2 Minutes</option>
                    <option value="3">3 Minutes</option>
                    <option value="5" selected>5 Minutes</option>
                    <option value="10">10 Minutes</option>
                    <option value="15">15 Minutes</option>
                    <option value="20">20 Minutes</option>
                    <option value="30">30 Minutes</option>
                </select>
            </div>

            <div class="setting-group">
                <label for="target-wpm">Your Target WPM (Optional):</label>
                <input type="number" id="target-wpm" min="10" max="200" placeholder="e.g., 40">
            </div>

            <div class="setting-group">
                <label for="target-accuracy">Your Target Accuracy % (Optional):</label>
                <input type="number" id="target-accuracy" min="50" max="100" placeholder="e.g., 95">
            </div>

            <div class="setting-group">
                <label for="story-type">Story Type:</label>
                <select id="story-type">
                    <option value="random-words" selected>Random Words (Default)</option>
                    <option value="ai-story">AI Generated Story (Requires Backend)</option>
                    <option value="user-custom">User Custom Story</option>
                </select>
            </div>

            <div id="custom-story-area">
                <label for="custom-story-textarea">Paste your story here:</label>
                <textarea id="custom-story-textarea" placeholder="Paste the text you want to type here..."></textarea>
                <div class="custom-story-controls">
                    <button class="button secondary" id="add-story-link-button">Add Story from Reedsy</button>
                </div>
            </div>

            <div class="button-group">
                <button class="button primary" id="save-settings-button">Start Test</button>
                <button class="button secondary" id="skip-settings-button">Skip & Start Default</button>
            </div>
        </div>
    </div>

    <div class="container content-hidden" id="main-content">
        <h1>Advanced English Typing Test</h1>

        <div class="stats top-stats">
            <div class="stat-item">
                <h3>Speed (WPM)</h3>
                <p id="wpm">0</p>
            </div>
            <div class="stat-item">
                <h3>Accuracy (%)</h3>
                <p id="accuracy">0</p>
            </div>
            <div class="stat-item">
                <h3>Errors</h3>
                <p id="errors">0</p>
            </div>
            <div class="stat-item cpm-item">
                <h3>CPM</h3>
                <p id="cpm">0</p>
            </div>
            <div class="stat-item timer-item">
                <h3>Time Left</h3>
                <p id="countdown">00:00</p>
            </div>
        </div>

        <div class="test-area" id="test-area">
            </div>

        <input type="text" id="typing-input" placeholder="Start typing here...">

        <div class="controls">
            <button class="button primary" id="restart-button">Restart Test</button>
            <button class="button secondary" id="settings-button">Settings</button>
        </div>

        <div class="result-modal" id="result-modal">
            <div class="modal-content">
                <h2>Test Results</h2>
                <div class="stats">
                    <div class="stat-item">
                        <h3>Final Speed (WPM)</h3>
                        <p id="final-wpm" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final Accuracy (%)</h3>
                        <p id="final-accuracy" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Total Errors</h3>
                        <p id="final-errors" class="result-value-red">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Raw WPM</h3>
                        <p id="raw-wpm" class="result-value-purple">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final CPM</h3>
                        <p id="final-cpm" class="result-value-orange">0</p>
                    </div>
                    <div class="stat-item target-status" id="wpm-target-status">
                        <h3>WPM Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                    <div class="stat-item target-status" id="accuracy-target-status">
                        <h3>Accuracy Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                </div>
                <button class="button primary" id="modal-restart-button">Restart Test</button>
                <button class="button secondary" id="modal-settings-button">New Test with Settings</button>
            </div>
        </div>
    </div>

    <script>
        // Function to fetch AI-generated stories (simulated for now)
        async function fetchAIGeneratedStory(lengthCategory = 'medium') {
            // In a real application, this would be an API call to your backend
            // For GitHub Pages, you'd need to deploy a backend (e.g., on Render)
            // and replace this with your actual API endpoint.
            // Example: const response = await fetch('YOUR_BACKEND_API_ENDPOINT/generate-story', {
            //    method: 'POST',
            //    headers: { 'Content-Type': 'application/json' },
            //    body: JSON.stringify({ length: lengthCategory })
            // });
            // const data = await response.json();
            // return data.story;

            // --- MOCK AI GENERATION FOR FRONTEND ONLY ---
            // Since we can't run real AI on GitHub Pages without a backend,
            // we'll simulate it by picking a longer random passage from a predefined list.
            const longStories = [
                "In a quaint village nestled between rolling hills and a winding river, lived a curious young inventor named Elara. Her days were spent tinkering with gears, wires, and strange contraptions in her small, cluttered workshop. The villagers often chuckled at her eccentricities, but they also secretly admired her unwavering dedication. One day, a fierce storm swept through the valley, knocking out power and isolating the village. Elara, with a twinkle in her eye, knew this was her moment to shine. She unveiled her latest invention: a device that could harness the raw energy of the storm itself, providing light and warmth to every home. With a flick of a switch, the village square lit up, casting a warm glow that banished the darkness and brought hope to the hearts of the people. From that day forward, Elara was no longer just a curious inventor; she was their beacon of light.",
                "The ancient library was a labyrinth of forgotten knowledge, its shelves stretching towards a vaulted ceiling, filled with books bound in leather and imbued with the scent of aged paper. Maya, an aspiring historian, had always dreamed of uncovering its secrets. Legend spoke of a hidden chamber, accessible only to those who could decipher the riddles woven into the very architecture of the building. Armed with a dusty map and her keen intellect, Maya spent weeks tracing symbols and solving puzzles, her fingers trailing over forgotten inscriptions. Finally, a section of the wall receded with a soft click, revealing a spiral staircase descending into darkness. Below, she found not gold or jewels, but a single, illuminated tome, its pages filled with the true history of their world, a history far grander and more intricate than any she had ever read.",
                "The city of Neo-Veridia hummed with the silent thrum of hover-cars and the glow of holographic advertisements. Humans and advanced AI lived side-by-side, their lives intertwined in a complex dance of technology and tradition. Kael, a data archivist, spent his days sifting through digital remnants of the past, seeking patterns and anomalies. One evening, he stumbled upon a peculiar data stream – an encrypted message from an unknown source, speaking of a long-lost natural world, untouched by urbanization. Driven by an insatiable curiosity, Kael followed the digital breadcrumbs, leading him to an ancient, forgotten port where a single, dilapidated spacecraft awaited. It was a journey into the unknown, a quest to find the whispered legends of green forests, blue oceans, and the untamed beauty of a world before concrete and chrome."
            ];
            const shortStories = [
                "The cat slept soundly by the fire, purring softly. A gentle rain fell outside, tapping on the windowpane. Soon, morning light would fill the room, waking the house. Life was simple and good.",
                "A tiny seed lay buried deep in the earth, dreaming of the sun. Slowly, it pushed a root down and a sprout up. Green leaves unfurled, reaching for the sky. It grew into a strong oak tree.",
                "The old lighthouse stood tall against the stormy sea, its beam cutting through the fog. For generations, it guided ships safely to shore. A silent guardian, it watched over the waves.",
                "She picked up her brush and dabbed paint onto the canvas. Colors swirled, forming landscapes and dreams. Each stroke brought a new world to life, born from her imagination and skill."
            ];
            const randomWordList = [
                "the", "quick", "brown", "fox", "jumps", "over", "lazy", "dog", "typing", "practice", "keyboard", "speed", "accuracy", "challenge", "learn", "javascript", "html", "css", "web", "development", "program", "computer", "science", "internet", "browser", "editor", "function", "variable", "element", "document", "style", "console", "terminal", "algorithm", "data", "structure", "network", "server", "client", "request", "response", "protocol", "security", "encryption", "database", "query", "framework", "library", "component", "module", "package", "version", "control", "repository", "commit", "branch", "merge", "pull", "push", "remote", "local", "online", "offline", "connect", "disconnect", "upload", "download", "install", "update", "delete", "create", "read", "write", "execute", "debug", "test", "deploy", "monitor", "optimize", "scale", "automate", "build", "run", "stop", "start", "restart", "configure", "setup", "manage", "organize", "design", "develop", "implement", "maintain", "support", "troubleshoot", "resolve", "solution", "problem", "issue", "error", "warning", "success", "failure", "progress", "status", "report", "log", "history", "analytics", "metric", "performance", "resource", "memory", "cpu", "disk", "bandwidth", "latency", "throughput", "reliability", "availability", "scalability", "maintainability", "usability", "flexibility", "extensibility", "portability", "security", "integrity", "confidentiality", "authentication", "authorization", "audit", "compliance", "regulation", "standard", "guideline", "best", "practice", "pattern", "design", "architecture", "model", "diagram", "flowchart", "pseudocode", "documentation", "comment", "refactor", "optimize", "debug", "test", "deploy", "monitor", "alert", "log", "trace", "profile", "benchmark", "analysis", "report", "summary", "detail", "overview", "context", "scope", "requirement", "specification", "feature", "bug", "fix", "patch", "release", "version", "update", "upgrade", "downgrade", "install", "uninstall", "setup", "configure", "customize", "personalize", "settings", "options", "preferences", "profile", "account", "user", "admin", "guest", "role", "permission", "access", "control", "security", "privacy", "data", "information", "knowledge", "wisdom", "intelligence", "learning", "education", "training", "course", "lesson", "tutorial", "guide", "manual", "book", "article", "blog", "forum", "community", "support", "help", "faq", "troubleshoot", "debug", "solve", "resolve", "fix", "repair", "restore", "backup", "recover", "archive", "compress", "decompress", "encrypt", "decrypt", "hash", "checksum", "validate", "verify", "authenticate", "authorize", "grant", "revoke", "deny", "allow", "enable", "disable", "toggle", "switch", "activate", "deactivate", "start", "stop", "pause", "resume", "cancel", "abort", "retry", "redo", "undo", "save", "load", "open", "close", "new", "edit", "delete", "copy", "cut", "paste", "select", "all", "clear", "reset", "submit", "send", "receive", "download", "upload", "import", "export", "share", "print", "preview", "zoom", "in", "out", "fit", "width", "height", "actual", "size", "fullscreen", "exit", "search", "filter", "sort", "group", "categorize", "tag", "label", "mark", "favorite", "bookmark", "pin", "hide", "show", "collapse", "expand", "move", "rename", "duplicate", "clone", "merge", "split", "join", "combine", "separate", "extract", "insert", "remove", "replace", "find", "replace", "goto", "line", "column", "character", "word", "sentence", "paragraph", "document", "file", "folder", "directory", "path", "url", "uri", "urn", "protocol", "host", "port", "query", "fragment", "scheme", "authority", "userinfo", "hostname", "pathname", "search", "hash", "origin", "protocol", "domain", "subdomain", "top-level", "second-level", "country-code", "generic", "reserved", "public", "private", "local", "global", "internal", "external", "remote", "cloud", "on-premise", "hybrid", "distributed", "centralized", "decentralized", "peer-to-peer", "client-server", "front-end", "back-end", "full-stack", "desktop", "mobile", "web", "native", "cross-platform", "hybrid", "responsive", "adaptive", "fluid", "fixed", "grid", "flexbox", "bootstrap", "material", "design", "ui", "ux", "interface", "experience", "interaction", "usability", "accessibility", "performance", "security", "scalability", "reliability", "availability", "maintainability", "testability", "extensibility", "flexibility", "portability", "reusability", "modularity", "simplicity", "consistency", "efficiency", "robustness", "error-handling", "logging", "monitoring", "debugging", "testing", "deployment", "automation", "scripting", "programming", "coding", "software", "hardware", "firmware", "middleware", "operating", "system", "kernel", "shell", "command", "line", "interface", "graphical", "user", "interface", "api", "sdk", "library", "framework", "tool", "utility", "application", "program", "service", "daemon", "process", "thread", "concurrency", "parallelism", "synchronization", "asynchronous", "callback", "promise", "async", "await", "event", "loop", "queue", "stack", "heap", "tree", "graph", "linked", "list", "array", "object", "map", "set", "iterator", "generator", "decorator", "closure", "higher-order", "function", "pure", "function", "side-effect", "idempotent", "immutable", "mutable", "state", "stateless", "stateful", "component", "props", "state", "lifecycle", "hook", "context", "provider", "consumer", "reducer", "action", "dispatch", "store", "subscribe", "unsubscribe", "middleware", "thunk", "saga", "redux", "mobx", "vuex", "angular", "react", "vue", "jquery", "lodash", "underscore", "moment", "date-fns", "axios", "fetch", "websocket", "socket.io", "graphql", "rest", "api", "json", "xml", "yaml", "csv", "tsv", "markdown", "html", "css", "javascript", "typescript", "python", "java", "csharp", "go", "rust", "php", "ruby", "swift", "kotlin", "scala", "haskell", "clojure", "lisp", "erlang", "elixir", "perl", "bash", "shell", "powershell", "sql", "nosql", "mongodb", "postgresql", "mysql", "sqlite", "redis", "cassandra", "elasticsearch", "kafka", "rabbit", "mq", "aws", "azure", "gcp", "docker", "kubernetes", "git", "github", "gitlab", "bitbucket", "jenkins", "travis", "ci", "circleci", "github", "actions", "azure", "devops", "jira", "trello", "asana", "slack", "discord", "zoom", "google", "meet", "microsoft", "teams", "outlook", "gmail", "calendar", "drive", "docs", "sheets", "slides", "forms", "maps", "youtube", "twitter", "facebook", "instagram", "linkedin", "snapchat", "tiktok", "reddit", "pinterest", "whatsapp", "telegram", "signal", "viber", "wechat", "line", "skype", "facetime", "imessage", "sms", "email", "phone", "call", "video", "audio", "text", "message", "chat", "group", "channel", "thread", "notification", "alert", "badge", "icon", "button", "link", "input", "text", "area", "checkbox", "radio", "select", "option", "dropdown", "slider", "range", "progress", "bar", "spinner", "loader", "tooltip", "popover", "modal", "dialog", "accordion", "tabs", "carousel", "pagination", "breadcrumb", "navbar", "sidebar", "footer", "header", "main", "section", "article", "aside", "figure", "figcaption", "details", "summary", "dialog", "menu", "item", "list", "unordered", "ordered", "definition", "table", "row", "column", "cell", "caption", "thead", "tbody", "tfoot", "form", "fieldset", "legend", "label", "input", "textarea", "button", "select", "option", "datalist", "output", "meter", "progress", "img", "picture", "source", "svg", "canvas", "audio", "video", "track", "embed", "iframe", "object", "param", "map", "area", "link", "meta", "style", "script", "noscript", "template", "slot", "abbr", "address", "b", "bdi", "bdo", "blockquote", "cite", "code", "del", "dfn", "em", "i", "ins", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "acronym", "applet", "basefont", "big", "center", "dir", "font", "frame", "frameset", "noframes", "strike", "tt"
            ];
            // If random-words is selected, we combine words to form a longer story for variety
            if (lengthCategory === 'random-words') {
                let generatedText = "";
                // Increase base word count to ensure enough text for longer durations
                const baseWordCount = 300; 
                const targetWordCount = baseWordCount * (testDurationSelect.value / 5); 
                for (let i = 0; i < targetWordCount; i++) {
                    generatedText += randomWordList[Math.floor(Math.random() * randomWordList.length)] + " ";
                }
                return generatedText.trim();
            } else if (lengthCategory === 'short') {
                return shortStories[Math.floor(Math.random() * shortStories.length)];
            } else if (lengthCategory === 'long') {
                return longStories[Math.floor(Math.random() * longStories.length)];
            } else { // 'medium' or default AI story fallback
                return "The sun dipped below the horizon, painting the sky in hues of orange and purple. A lone bird soared across the fading light, its wings catching the last rays. Below, the city lights began to twinkle, promising a night of bustling activity. A gentle breeze carried the scent of blooming jasmine through the open window. It was a perfect evening to reflect on the day's events and anticipate the quiet hours ahead. The world felt at peace, a symphony of subtle changes unfolding as darkness embraced the landscape, bringing with it the promise of a new dawn and fresh opportunities. Every moment held a quiet beauty, a fleeting perfection that made the heart sing with gratitude for its simple existence.";
            }
        }
        // --- END MOCK AI GENERATION ---

        // DOM Elements
        const mainContent = document.getElementById('main-content');
        const testArea = document.getElementById('test-area');
        const typingInput = document.getElementById('typing-input');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const errorsDisplay = document.getElementById('errors');
        const cpmDisplay = document.getElementById('cpm'); // New CPM display
        const countdownDisplay = document.getElementById('countdown');
        const restartButton = document.getElementById('restart-button');
        const settingsButton = document.getElementById('settings-button');
        const resultModal = document.getElementById('result-modal');
        const finalWpmDisplay = document.getElementById('final-wpm');
        const finalAccuracyDisplay = document.getElementById('final-accuracy');
        const finalErrorsDisplay = document.getElementById('final-errors');
        const rawWpmDisplay = document.getElementById('raw-wpm');
        const finalCpmDisplay = document.getElementById('final-cpm'); // New Final CPM display
        const modalRestartButton = document.getElementById('modal-restart-button');
        const modalSettingsButton = document.getElementById('modal-settings-button');

        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settings-overlay');
        const testDurationSelect = document.getElementById('test-duration');
        const targetWpmInput = document.getElementById('target-wpm');
        const targetAccuracyInput = document.getElementById('target-accuracy');
        const storyTypeSelect = document.getElementById('story-type');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const skipSettingsButton = document.getElementById('skip-settings-button');
        const wpmTargetStatus = document.getElementById('wpm-target-status');
        const accuracyTargetStatus = document.getElementById('accuracy-target-status');

        // New Custom Story Elements
        const customStoryArea = document.getElementById('custom-story-area');
        const customStoryTextarea = document.getElementById('custom-story-textarea');
        const addStoryLinkButton = document.getElementById('add-story-link-button');

        // Global Variables
        let testWords = []; // This array will hold the expected words and '\n' markers
        let wordIndex = 0;
        let charIndex = 0; // Current character index within the current word
        let startTime;
        let timerInterval;
        let defaultTestDuration = 5 * 60; // Default 5 minutes in seconds
        let timeLeft = defaultTestDuration;
        let correctChars = 0; // Correct characters typed (for WPM/CPM)
        let incorrectChars = 0; // Incorrect characters typed
        let typedCharsOverall = 0; // Total characters user has attempted to type

        let userTargetWPM = null;
        let userTargetAccuracy = null;
        let currentStoryType = 'random-words'; // Default story type
        let customStoryText = ''; // Stores user's custom story

        // Utility to format time
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        async function generateAndRenderTestWords() {
            testWords = []; // Reset words for typing logic
            testArea.innerHTML = ''; // Clear previous content

            let textToType = "";

            if (currentStoryType === 'ai-story') {
                let lengthCategory = 'medium'; // Default for AI story
                const durationMinutes = parseInt(testDurationSelect.value);
                if (durationMinutes <= 2) {
                    lengthCategory = 'short';
                } else if (durationMinutes >= 10) {
                    lengthCategory = 'long';
                }
                textToType = await fetchAIGeneratedStory(lengthCategory);
            } else if (currentStoryType === 'user-custom') {
                textToType = customStoryText.trim();
                if (textToType === "") {
                    alert("Please paste your custom story in the text area or select another story type.");
                    settingsOverlay.classList.add('show');
                    mainContent.classList.add('content-hidden');
                    return false; // Indicate failure to generate
                }
            } else { // random-words
                textToType = await fetchAIGeneratedStory('random-words');
            }

            // Process text to handle paragraphs and line breaks
            // Split by any newline sequence (CRLF, LF, CR)
            const paragraphs = textToType.split(/\r?\n/); 

            paragraphs.forEach((paragraphText, paraIdx) => {
                const paragraphDiv = document.createElement('div');
                paragraphDiv.classList.add('paragraph');

                // Split words in a paragraph by one or more spaces
                const wordsInParagraph = paragraphText.split(/\s+/).filter(word => word.length > 0);

                wordsInParagraph.forEach((word, wordIdxInPara) => {
                    testWords.push(word); // Add word to our global testWords array

                    const wordSpan = document.createElement('span');
                    wordSpan.classList.add('word');
                    word.split('').forEach(char => {
                        const charSpan = document.createElement('span');
                        charSpan.textContent = char;
                        charSpan.classList.add('untyped');
                        wordSpan.appendChild(charSpan);
                    });

                    // Add a space span after each word (except the last one in the paragraph)
                    if (wordIdxInPara < wordsInParagraph.length - 1) {
                        const spaceSpan = document.createElement('span');
                        spaceSpan.textContent = ' '; // Represent space character
                        spaceSpan.classList.add('char-space');
                        spaceSpan.classList.add('untyped');
                        wordSpan.appendChild(spaceSpan);
                    }
                    paragraphDiv.appendChild(wordSpan);
                });

                // Add a newline marker if it's not the very last paragraph and there's actually content
                // Or if it's an empty line that should be preserved visually (empty paragraph)
                if (paraIdx < paragraphs.length -1) { // Check if it's not the last paragraph
                    // If the current paragraph is empty or just whitespace, we still want to indicate a newline
                    // This handles cases where user pastes multiple empty lines.
                    testWords.push('\n'); // Special indicator for newline
                }
                
                testArea.appendChild(paragraphDiv);
            });
            
            highlightCurrentWord();
            adjustTestAreaScroll();
            return true; // Indicate successful generation
        }

        // This function retrieves the DOM span element for a specific "word" in testWords
        // It needs to correctly navigate paragraphs and words within them.
        function getDomWordSpan(targetWordIndex) {
            let currentTraversalWordIndex = 0;
            const paragraphs = testArea.querySelectorAll('.paragraph');

            for (let i = 0; i < paragraphs.length; i++) {
                const paragraphDiv = paragraphs[i];
                const wordSpans = paragraphDiv.querySelectorAll('.word');

                for (let j = 0; j < wordSpans.length; j++) {
                    if (currentTraversalWordIndex === targetWordIndex) {
                        return wordSpans[j];
                    }
                    currentTraversalWordIndex++;
                }

                // If currentTraversalWordIndex matches wordIndex, and the testWords[wordIndex] is '\n',
                // it means we are at the end of a line/paragraph, and the "word" is the newline character.
                // We don't have a DOM element for the newline itself, but the next logical "word"
                // in testWords would be the first word of the next paragraph.
                // So, if we iterated through all words in a paragraph and we expect a '\n' in testWords,
                // we increment our traversal index to match testWords.
                if (testWords[currentTraversalWordIndex] === '\n' && currentTraversalWordIndex === targetWordIndex) {
                    return null; // A newline 'word' doesn't have a direct DOM span
                }
                 if (testWords[currentTraversalWordIndex] === '\n' && i < paragraphs.length -1) {
                    currentTraversalWordIndex++; // Account for the '\n' in testWords
                }
            }
            return null; // Word not found
        }


        function highlightCurrentWord() {
            // Remove highlighting from all words first
            testArea.querySelectorAll('.word').forEach(span => {
                span.classList.remove('current-word');
            });

            // If we are at the end of the test, or expecting a newline
            if (wordIndex >= testWords.length || testWords[wordIndex] === '\n') {
                adjustTestAreaScroll(); // Still adjust scroll if needed
                return;
            }

            const currentWordSpan = getDomWordSpan(wordIndex);
            if (currentWordSpan) {
                currentWordSpan.classList.add('current-word');
                adjustTestAreaScroll();
            }
        }


        // Function to automatically scroll the test area
        function adjustTestAreaScroll() {
            let targetElement = null;

            if (wordIndex < testWords.length) {
                if (testWords[wordIndex] === '\n') {
                    // If we are currently at a newline, we want to scroll to the beginning of the next paragraph
                    // to ensure the *next* actual word is visible.
                    let currentTraversalWordIndex = 0;
                    const paragraphs = testArea.querySelectorAll('.paragraph');
                    let foundCurrentParagraph = false;

                    for (let i = 0; i < paragraphs.length; i++) {
                        const paragraphDiv = paragraphs[i];
                        const wordSpans = paragraphDiv.querySelectorAll('.word');

                        for (let j = 0; j < wordSpans.length; j++) {
                            if (currentTraversalWordIndex === wordIndex) {
                                foundCurrentParagraph = true;
                                break;
                            }
                            currentTraversalWordIndex++;
                        }
                        if (foundCurrentParagraph) break;

                        if (testWords[currentTraversalWordIndex] === '\n' && currentTraversalWordIndex === wordIndex) {
                            foundCurrentParagraph = true; // Found the newline
                            // Now find the next paragraph's first word, if it exists
                            if (i + 1 < paragraphs.length) {
                                const nextParagraphDiv = paragraphs[i + 1];
                                if (nextParagraphDiv.children.length > 0) {
                                    targetElement = nextParagraphDiv.children[0]; // First word of next paragraph
                                }
                            }
                            break;
                        }
                        if (testWords[currentTraversalWordIndex] === '\n' && i < paragraphs.length -1) {
                            currentTraversalWordIndex++; // Account for the '\n'
                        }
                    }

                    // If a newline is the current "word", and we found the next paragraph's first word
                    if (targetElement) {
                        // proceed with scrolling logic below
                    } else {
                        // If no next word/paragraph (end of test), no need to scroll
                        return;
                    }

                } else {
                    targetElement = getDomWordSpan(wordIndex);
                }
            }

            if (!targetElement) return;

            const testAreaRect = testArea.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();

            // Calculate vertical scroll
            // If the target element's bottom is below the test area's visible bottom
            if (targetRect.bottom > testAreaRect.bottom) {
                testArea.scrollTop += (targetRect.bottom - testAreaRect.bottom) + 10; // Scroll down by diff + a little buffer
            }
            // If the target element's top is above the test area's visible top
            else if (targetRect.top < testAreaRect.top) {
                testArea.scrollTop -= (testAreaRect.top - targetRect.top) + 10; // Scroll up by diff + a little buffer
            }
        }


        function updateStats() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            if (timeElapsed === 0) {
                cpmDisplay.textContent = 0;
                return; // Avoid division by zero at start
            }

            const minutesElapsed = timeElapsed / 60;

            // WPM calculation: (Correct Words / Time in Minutes)
            // A "word" is often defined as 5 characters including spaces.
            // For more robust WPM, we can use (Correct Chars / 5)
            const currentWPM = Math.round((correctChars / 5) / minutesElapsed);
            wpmDisplay.textContent = isNaN(currentWPM) ? 0 : currentWPM;

            // CPM calculation: Total Correct Characters / (Time in Minutes)
            const currentCPM = Math.round(correctChars / minutesElapsed);
            cpmDisplay.textContent = isNaN(currentCPM) ? 0 : currentCPM;

            const currentAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            accuracyDisplay.textContent = isNaN(currentAccuracy) ? 0 : currentAccuracy;
            errorsDisplay.textContent = incorrectChars;
        }


        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = formatTime(timeLeft);
                updateStats();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endTest();
                }
            }, 1000);
        }

        function endTest() {
            typingInput.disabled = true;
            typingInput.value = '';
            clearInterval(timerInterval);
            updateStats(); // Final update

            const timeElapsed = (defaultTestDuration - timeLeft);
            const finalMinutesElapsed = timeElapsed / 60;

            // Handle potential division by zero if test ended immediately for some reason
            const finalWPM = finalMinutesElapsed > 0 ? Math.round((correctChars / 5) / finalMinutesElapsed) : 0;
            const finalAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            const finalRawWPM = finalMinutesElapsed > 0 ? Math.round((typedCharsOverall / 5) / finalMinutesElapsed) : 0;
            const finalCPM = finalMinutesElapsed > 0 ? Math.round(correctChars / finalMinutesElapsed) : 0;


            finalWpmDisplay.textContent = isNaN(finalWPM) ? 0 : finalWPM;
            finalAccuracyDisplay.textContent = isNaN(finalAccuracy) ? 0 : finalAccuracy;
            finalErrorsDisplay.textContent = incorrectChars;
            rawWpmDisplay.textContent = isNaN(finalRawWPM) ? 0 : finalRawWPM;
            finalCpmDisplay.textContent = isNaN(finalCPM) ? 0 : finalCPM; // Set Final CPM

            // Add color to final results
            finalWpmDisplay.className = 'result-value-green';
            finalAccuracyDisplay.className = 'result-value-green';
            finalErrorsDisplay.className = 'result-value-red'; // Errors are bad, so red
            rawWpmDisplay.className = 'result-value-purple';
            finalCpmDisplay.className = 'result-value-orange';


            // Check and update target status
            if (userTargetWPM !== null && !isNaN(userTargetWPM)) {
                if (finalWPM >= userTargetWPM) {
                    wpmTargetStatus.querySelector('p').textContent = `Met (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    wpmTargetStatus.querySelector('p').textContent = `Missed (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                wpmTargetStatus.querySelector('p').textContent = 'N/A';
                wpmTargetStatus.querySelector('p').className = 'status-neutral';
            }

            if (userTargetAccuracy !== null && !isNaN(userTargetAccuracy)) {
                if (finalAccuracy >= userTargetAccuracy) {
                    accuracyTargetStatus.querySelector('p').textContent = `Met (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    accuracyTargetStatus.querySelector('p').textContent = `Missed (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                accuracyTargetStatus.querySelector('p').textContent = 'N/A';
                accuracyTargetStatus.querySelector('p').className = 'status-neutral';
            }

            resultModal.classList.add('show');
            // Allow restart and settings access after test ends
            restartButton.disabled = false;
            settingsButton.disabled = false;
        }

        async function initializeTest(duration, targetWPM, targetAccuracy, storyType, customText = '') {
            clearInterval(timerInterval);
            defaultTestDuration = duration * 60; // Convert minutes to seconds
            timeLeft = defaultTestDuration;
            countdownDisplay.textContent = formatTime(timeLeft);
            wordIndex = 0;
            charIndex = 0; // Reset charIndex for new word
            correctChars = 0;
            incorrectChars = 0;
            typedCharsOverall = 0;
            typingInput.value = '';
            typingInput.disabled = false;
            startTime = null; // Reset start time
            
            userTargetWPM = targetWPM ? parseInt(targetWPM) : null;
            userTargetAccuracy = targetAccuracy ? parseInt(targetAccuracy) : null;
            currentStoryType = storyType;
            customStoryText = customText; // Set custom story if provided

            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '0';
            errorsDisplay.textContent = '0';
            cpmDisplay.textContent = '0'; // Reset CPM display

            // Ensure buttons are clickable for a new test or settings
            restartButton.disabled = false; 
            settingsButton.disabled = false;
            
            // Generate words and check if successful (e.g., custom story not empty)
            const generationSuccess = await generateAndRenderTestWords();
            if (!generationSuccess) {
                // If story generation failed (e.g., empty custom story), do not proceed
                return;
            }

            typingInput.focus();
            resultModal.classList.remove('show');
            settingsOverlay.classList.remove('show'); // Hide settings overlay
            mainContent.classList.remove('content-hidden'); // Show main content
        }

        // Event Listeners

        // Typing Input Listener
        typingInput.addEventListener('input', (e) => {
            if (!startTime) {
                startTimer(); // Start timer on first input
            }
            
            const currentExpectedItem = testWords[wordIndex];
            const typedText = e.target.value;
            
            // If we are expecting a newline, 'input' event won't trigger the end of the 'word'
            // The keydown handler for Enter will handle the newline 'word' completion.
            if (currentExpectedItem === '\n') {
                // Any characters typed here are considered incorrect for the 'newline'
                // and should be immediately cleared, but let's let keydown handle the full logic.
                // For now, just ensure it doesn't break.
                return; 
            }

            const currentWordExpected = currentExpectedItem; 
            const currentWordSpan = getDomWordSpan(wordIndex); 

            if (!currentWordSpan) { 
                endTest(); // Should not happen if wordIndex is valid
                return;
            }

            const charSpans = Array.from(currentWordSpan.querySelectorAll('span:not(.char-space)')); 
            const spaceSpan = currentWordSpan.querySelector('.char-space'); // Get the space span if it exists

            // Reset all spans in current word to untyped and remove correctness classes
            charSpans.forEach(span => {
                span.classList.remove('correct', 'incorrect', 'extra');
                span.classList.add('untyped');
                span.style.display = 'inline'; // Ensure they are visible
            });
            if (spaceSpan) {
                spaceSpan.classList.remove('correct', 'incorrect');
                spaceSpan.classList.add('untyped');
                spaceSpan.style.display = 'inline';
            }


            // Update char rendering within the current word
            // charIndex tracks how many characters of the current word have been correctly typed
            // and charIndex is used to mark correct/incorrect.
            let currentWordCorrectChars = 0;

            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                const charSpan = charSpans[i];

                if (charSpan) {
                    if (typedChar === undefined) {
                        charSpan.classList.add('untyped');
                    } else if (typedChar.toLowerCase() === charExpected.toLowerCase()) { // Case-insensitive comparison
                        charSpan.classList.add('correct');
                        currentWordCorrectChars++;
                    } else {
                        charSpan.classList.add('incorrect');
                    }
                }
            }

            // Handle the space character (if it exists for this word)
            if (spaceSpan) {
                if (typedText[currentWordExpected.length] === ' ') {
                    spaceSpan.classList.add('correct');
                } else if (typedText[currentWordExpected.length] !== undefined) {
                    spaceSpan.classList.add('incorrect');
                } else {
                    spaceSpan.classList.add('untyped');
                }
            }

            // Handle extra characters typed (beyond the current word's length AND potential space)
            // First, remove any existing extra spans
            currentWordSpan.querySelectorAll('.extra').forEach(el => el.remove());

            // Then, create and add new extra chars
            const expectedCharsInDom = currentWordExpected.length + (spaceSpan ? 1 : 0);
            if (typedText.length > expectedCharsInDom) {
                for (let i = expectedCharsInDom; i < typedText.length; i++) {
                    const extraSpan = document.createElement('span');
                    extraSpan.textContent = typedText[i];
                    extraSpan.classList.add('extra');
                    currentWordSpan.appendChild(extraSpan);
                }
            }
            
            // Check if word is completed (by typing a space or if it's the last word and matches)
            const isLastWord = wordIndex === testWords.length - 1;
            const typedWordIsComplete = (typedText.endsWith(' ') && typedText.trim().toLowerCase() === currentWordExpected.toLowerCase()) || 
                                       (isLastWord && typedText.toLowerCase() === currentWordExpected.toLowerCase());

            if (typedWordIsComplete) {
                let tempCorrectCharsForWord = 0;
                let tempIncorrectCharsForWord = 0;

                // Calculate chars for the actual word part
                for (let i = 0; i < currentWordExpected.length; i++) {
                    if (typedText[i] && typedText[i].toLowerCase() === currentWordExpected[i].toLowerCase()) {
                        tempCorrectCharsForWord++;
                    } else if (typedText[i]) { // typed but incorrect
                        tempIncorrectCharsForWord++;
                    } else { // missed character
                        tempIncorrectCharsForWord++;
                    }
                }

                // Calculate chars for the space (if it exists)
                if (spaceSpan) {
                    if (typedText[currentWordExpected.length] === ' ') {
                        tempCorrectCharsForWord++;
                    } else if (typedText[currentWordExpected.length] !== undefined) {
                        tempIncorrectCharsForWord++;
                    } else { // Missed space
                        tempIncorrectCharsForWord++;
                    }
                }

                // Account for extra characters typed beyond the expected word (+ space)
                const expectedTotalLength = currentWordExpected.length + (spaceSpan ? 1 : 0);
                if (typedText.length > expectedTotalLength) {
                    tempIncorrectCharsForWord += (typedText.length - expectedTotalLength);
                }
                
                correctChars += tempCorrectCharsForWord;
                incorrectChars += tempIncorrectCharsForWord;
                typedCharsOverall += typedText.length; // Count all characters actually typed for this word

                wordIndex++; // Move to next word
                charIndex = 0; // Reset charIndex for the new word
                typingInput.value = ''; // Clear input for next word
                highlightCurrentWord(); // Update highlighting and scroll

                if (wordIndex >= testWords.length) { // End test if all words/newlines are typed
                    endTest();
                    return;
                }
            }
            updateStats(); // Update stats in real-time
        });


        // Handle Enter key for custom stories with newlines
        typingInput.addEventListener('keydown', (e) => {
            if (!startTime) {
                startTimer();
            }

            if (e.key === 'Enter') {
                const currentExpectedItem = testWords[wordIndex];

                // Check if we are actually expecting a newline
                if (currentExpectedItem === '\n') {
                    e.preventDefault(); // Prevent default Enter behavior (new line in input box)

                    // Any characters typed in the input before Enter when expecting newline are errors
                    if (typingInput.value.length > 0) {
                        incorrectChars += typingInput.value.length;
                        typedCharsOverall += typingInput.value.length;
                    }
                    
                    // Mark this "newline" as correctly processed
                    correctChars++; // Count newline as one correct char for CPM/WPM calculation
                    typedCharsOverall++; 

                    wordIndex++; // Move past the '\n' "word"
                    charIndex = 0; // Reset charIndex
                    typingInput.value = ''; // Clear input
                    highlightCurrentWord(); // Re-highlight (moves to next actual word)

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                    updateStats();
                } else {
                    // If Enter is pressed but we are not expecting a newline, it's an error
                    e.preventDefault(); // Still prevent default, just treat as an error
                    incorrectChars++;
                    typedCharsOverall++;
                    // Optionally: flash a red background or play an error sound
                    // For now, just count the error.
                    updateStats();
                }
            } else if (e.key === 'Backspace') {
                // No specific logic needed here as 'input' event re-renders everything
                // based on the current value of typingInput.value, which implicitly
                // handles backspaces and character removal from the visual feedback.
            }
        });


        restartButton.addEventListener('click', () => {
            // Show settings overlay on restart
            settingsOverlay.classList.add('show');
            resultModal.classList.remove('show'); // Hide result modal if open
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly on re-opening settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        settingsButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        saveSettingsButton.addEventListener('click', async () => {
            const duration = parseInt(testDurationSelect.value);
            const targetWPM = targetWpmInput.value;
            const targetAccuracy = targetAccuracyInput.value;
            const storyType = storyTypeSelect.value;
            let storyContent = '';

            if (storyType === 'user-custom') {
                storyContent = customStoryTextarea.value.trim();
            }
            await initializeTest(duration, targetWPM, targetAccuracy, storyType, storyContent);
        });

        skipSettingsButton.addEventListener('click', async () => {
            await initializeTest(5, null, null, 'random-words'); // Default to 5 mins, no targets, random words
        });

        modalRestartButton.addEventListener('click', async () => {
            await initializeTest(defaultTestDuration / 60, userTargetWPM, userTargetAccuracy, currentStoryType, customStoryText); // Use current settings for restart
        });

        modalSettingsButton.addEventListener('click', () => {
            resultModal.classList.remove('show');
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for Story Type dropdown to show/hide custom story area
        storyTypeSelect.addEventListener('change', () => {
            if (storyTypeSelect.value === 'user-custom') {
                customStoryArea.style.display = 'block';
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for "Add Story from Reedsy" button
        addStoryLinkButton.addEventListener('click', () => {
            window.open('https://blog.reedsy.com/short-stories/', '_blank');
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            settingsOverlay.classList.add('show');
            // Hide main content initially
            mainContent.classList.add('content-hidden');
            countdownDisplay.textContent = formatTime(defaultTestDuration); // Show initial default time
            // Ensure custom story area is hidden initially
            customStoryArea.style.display = 'none';
        });

    </script>
</body>
</html>
