<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced English Typing Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Source+Code+Pro:wght@400;700&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Font Imports */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #e3f2fd; /* Light Blue background */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align at the top */
            min-height: 100vh;
            padding: 20px;
            background: linear-gradient(to right, #e3f2fd, #fce4ec); /* Light Blue to Light Pink Gradient */
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15); /* More prominent shadow */
            width: 100%;
            max-width: 900px;
            animation: fadeIn 0.8s ease-out;
            border: 1px solid #bbdefb; /* Light blue border */
            position: relative; /* For z-index to work with settings overlay */
            z-index: 1; /* Ensure container is above other elements when settings are hidden */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            text-align: center;
            color: #e91e63; /* Pink primary color */
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5em; /* Larger title */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }

        /* Live Stats Area (moved to top) */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px; /* Space below stats */
            flex-wrap: wrap;
            gap: 15px;
            background-color: #fce4ec; /* Light pink background */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }

        .stat-item {
            background-color: #fff;
            padding: 12px 18px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            text-align: center;
            min-width: 120px;
            flex: 1;
            border: 1px solid #f8bbd0; /* Slightly darker pink border */
        }

        .stat-item h3 {
            color: #6a1b9a; /* Deep purple for sub-headers */
            font-size: 1em;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .stat-item p {
            font-size: 1.8em; /* Slightly smaller for compactness */
            font-weight: bold;
            color: #e91e63; /* Pink for values */
            font-family: 'Montserrat', sans-serif;
        }

        .timer-item p {
            color: #2196f3; /* Blue for timer */
        }
        
        /* New: Live CPM display style */
        .cpm-item p {
            color: #ff9800; /* Orange for CPM */
        }

        /* Test Area */
        .test-area {
            margin-bottom: 20px; /* Reduced margin */
            padding: 20px;
            background-color: #f1f8e9; /* Very light green for contrast */
            border-radius: 10px;
            border: 1px solid #dcedc8;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            min-height: 120px; /* Smaller height */
            max-height: 120px; /* Fixed height for 3 lines */
            overflow: hidden; /* Hide overflow */
            position: relative;
            line-height: 1.8; /* More spacing for readability */
            font-size: 1.2em; /* Slightly smaller font for more words per line */
            font-family: 'Open Sans', sans-serif; /* Changed to Open Sans for better readability */
            color: #444;
        }

        /* For handling paragraphs and line breaks in test-area */
        .paragraph {
            margin-bottom: 1.5em; /* Space between paragraphs */
            white-space: pre-wrap; /* Preserves whitespace and wraps text */
        }

        .word {
            display: inline-block;
            margin-right: 5px;
            padding: 1px 0;
            white-space: pre-wrap; /* Ensure words don't break mid-char for spaces */
        }
        
        /* New: Visual representation for newline character for user awareness */
        .newline-marker {
            display: inline-block;
            width: 20px; /* Width to resemble a small 'enter' key */
            height: 18px; /* Height */
            background-color: #cfd8dc; /* Light grey */
            border-radius: 3px;
            margin-left: 5px; /* Space from previous word */
            margin-right: 5px;
            vertical-align: middle;
            text-align: center;
            font-size: 0.8em;
            color: #607d8b;
            line-height: 18px; /* Center text vertically */
            position: relative;
            top: -2px; /* Adjust vertical position */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .newline-marker::after {
            content: "‚èé"; /* Enter symbol */
        }


        .current-word {
            background-color: #fff9c4; /* Light yellow for current word */
            border-radius: 4px;
            padding: 1px 5px;
            box-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
        }
        /* New: Highlight for current newline marker */
        .current-newline-marker {
            background-color: #fff9c4; /* Match word highlight */
            border: 1px solid #ffeb3b; /* Stronger border */
            box-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
        }

        .correct {
            color: #388e3c; /* Dark green for correct */
        }

        .incorrect {
            color: #d32f2f; /* Dark red for incorrect */
            text-decoration: underline wavy #d32f2f 2px;
        }

        .extra {
            color: #7b7b7b;
            background-color: #ffebee; /* Very light red background for extra */
            border-radius: 3px;
            padding: 0 2px;
        }

        .untyped {
            color: #7b7b7b;
        }

        /* Input Area */
        #typing-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.5em;
            border: 2px solid #ccc;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Source Code Pro', monospace; /* Kept monospace for input */
            background-color: #fcfcfc;
            margin-bottom: 20px; /* Space below input */
        }

        #typing-input:focus {
            border-color: #2196f3; /* Blue on focus */
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
        }

        /* Controls */
        .controls {
            text-align: center;
            margin-top: 20px; /* Reduced margin */
        }

        .button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px; /* Slightly more rounded buttons */
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            margin: 0 10px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
        }

        .button.primary {
            background-color: #e91e63; /* Pink primary */
            color: white;
            box-shadow: 0 4px 8px rgba(233, 30, 99, 0.2);
        }

        .button.primary:hover {
            background-color: #d81b60; /* Darker pink on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(233, 30, 99, 0.3);
        }

        .button.secondary {
            background-color: #2196f3; /* Blue secondary */
            color: white;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.2);
        }

        .button.secondary:hover {
            background-color: #1976d2; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(33, 150, 243, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Result Modal */
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .result-modal.show {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            max-width: 600px; /* Wider modal */
            width: 90%;
            border: 1px solid #bbdefb;
        }

        .result-modal.show .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            color: #e91e63;
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2em;
        }

        .modal-content .stats {
            flex-wrap: wrap; /* Ensure wrapping in modal too */
            justify-content: center;
            margin-bottom: 20px;
        }

        .modal-content .stat-item {
            margin-bottom: 15px;
            background-color: #e3f2fd; /* Light blue in modal stats */
            border: 1px solid #90caf9;
        }

        /* Result Colors */
        .result-value-green {
            color: #388e3c; /* Green for good results (WPM, Accuracy) */
        }
        .result-value-red {
            color: #d32f2f; /* Red for bad results (Errors) */
        }
        .result-value-orange {
            color: #ff9800; /* Orange for CPM */
        }
        .result-value-purple {
            color: #6a1b9a; /* Purple for Raw WPM */
        }


        .modal-content .button {
            margin-top: 25px;
            margin: 10px; /* Space between modal buttons */
        }

        /* Target Status in Modal */
        .stat-item.target-status p {
            font-size: 1.5em; /* Smaller font for target status */
        }
        .status-neutral { color: #607d8b; } /* Grey */
        .status-met { color: #388e3c; } /* Green */
        .status-not-met { color: #d32f2f; } /* Red */

        /* Settings Overlay (Full-screen) */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker, more opaque background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher z-index than container and result modal */
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.4s ease;
        }

        .settings-overlay.show {
            visibility: visible;
            opacity: 1;
        }

        .settings-overlay .settings-content {
            background-color: #f0f4c3; /* Light yellow-green for settings */
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            border: 1px solid #cddc39;
            transform: scale(0.9);
            transition: transform 0.4s ease;

            /* Fix for overflow on settings screen */
            max-height: 90vh; /* Limit height to 90% of viewport height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }

        .settings-overlay.show .settings-content {
            transform: scale(1);
        }

        .settings-overlay h2 {
            color: #4CAF50; /* Green for settings header */
            margin-bottom: 30px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2em;
        }

        .setting-group {
            margin-bottom: 25px; /* More space between groups */
            text-align: left;
        }

        .setting-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px; /* More space below label */
            color: #388e3c; /* Darker green for setting labels */
            font-size: 1.15em;
        }

        .setting-group select,
        .setting-group input[type="number"] {
            width: 100%;
            padding: 12px; /* Larger padding for inputs */
            border: 1px solid #aed581; /* Greenish border */
            border-radius: 8px;
            font-size: 1.1em;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Roboto', sans-serif;
        }

        .setting-group select:focus,
        .setting-group input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        /* New: Custom Story Area styles */
        #custom-story-area {
            display: none; /* Hidden by default */
            margin-top: 20px;
            border-top: 1px solid #cddc39;
            padding-top: 20px;
        }

        #custom-story-textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid #aed581;
            border-radius: 8px;
            font-size: 1.1em;
            font-family: 'Open Sans', sans-serif;
            resize: vertical;
            margin-bottom: 10px;
        }

        #custom-story-textarea:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        .custom-story-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .custom-story-controls .button {
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 48%; /* Adjust for spacing */
        }
        
        @media (max-width: 480px) {
            .custom-story-controls .button {
                max-width: 100%; /* Stack buttons on very small screens */
            }
        }


        .settings-overlay .button-group {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        /* Initial hidden state for the main content */
        .content-hidden {
            visibility: hidden;
            opacity: 0;
            height: 0;
            overflow: hidden;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            .stats {
                gap: 10px;
            }

            .stat-item {
                min-width: 100px;
                padding: 10px 12px;
            }

            .stat-item p {
                font-size: 1.5em;
            }

            .test-area {
                font-size: 1.1em;
                padding: 15px;
                min-height: 100px;
                max-height: 100px;
            }

            #typing-input {
                font-size: 1.2em;
                padding: 10px 15px;
            }

            .button {
                padding: 10px 20px;
                font-size: 1em;
                margin: 5px;
            }

            .modal-content {
                padding: 25px;
            }

            .modal-content h2 {
                font-size: 1.8em;
            }

            .settings-overlay .settings-content {
                padding: 25px;
            }
            .settings-overlay h2 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            .setting-group {
                margin-bottom: 20px;
            }
            .settings-overlay .button-group {
                flex-direction: column;
                gap: 15px;
            }
            .settings-overlay .button {
                width: 80%; /* Make buttons wider on small screens */
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <div class="settings-overlay" id="settings-overlay">
        <div class="settings-content">
            <h2>Typing Test Settings</h2>
            <div class="setting-group">
                <label for="test-duration">Select Test Duration:</label>
                <select id="test-duration">
                    <option value="1">1 Minute</option>
                    <option value="2">2 Minutes</option>
                    <option value="3">3 Minutes</option>
                    <option value="5" selected>5 Minutes</option>
                    <option value="10">10 Minutes</option>
                    <option value="15">15 Minutes</option>
                    <option value="20">20 Minutes</option>
                    <option value="30">30 Minutes</option>
                </select>
            </div>

            <div class="setting-group">
                <label for="target-wpm">Your Target WPM (Optional):</label>
                <input type="number" id="target-wpm" min="10" max="200" placeholder="e.g., 40">
            </div>

            <div class="setting-group">
                <label for="target-accuracy">Your Target Accuracy % (Optional):</label>
                <input type="number" id="target-accuracy" min="50" max="100" placeholder="e.g., 95">
            </div>

            <div class="setting-group">
                <label for="story-type">Story Type:</label>
                <select id="story-type">
                    <option value="random-words" selected>Random Words (Default)</option>
                    <option value="ai-story">AI Generated Story (Requires Backend)</option>
                    <option value="user-custom">User Custom Story</option>
                </select>
            </div>

            <div id="custom-story-area">
                <label for="custom-story-textarea">Paste your story here:</label>
                <textarea id="custom-story-textarea" placeholder="Paste the text you want to type here..."></textarea>
                <div class="custom-story-controls">
                    <button class="button secondary" id="add-story-link-button">Add Story from Reedsy</button>
                </div>
            </div>

            <div class="button-group">
                <button class="button primary" id="save-settings-button">Start Test</button>
                <button class="button secondary" id="skip-settings-button">Skip & Start Default</button>
            </div>
        </div>
    </div>

    <div class="container content-hidden" id="main-content">
        <h1>Advanced English Typing Test</h1>

        <div class="stats top-stats">
            <div class="stat-item">
                <h3>Speed (WPM)</h3>
                <p id="wpm">0</p>
            </div>
            <div class="stat-item">
                <h3>Accuracy (%)</h3>
                <p id="accuracy">0</p>
            </div>
            <div class="stat-item">
                <h3>Errors</h3>
                <p id="errors">0</p>
            </div>
            <div class="stat-item cpm-item">
                <h3>CPM</h3>
                <p id="cpm">0</p>
            </div>
            <div class="stat-item timer-item">
                <h3>Time Left</h3>
                <p id="countdown">00:00</p>
            </div>
        </div>

        <div class="test-area" id="test-area">
            </div>

        <input type="text" id="typing-input" placeholder="Start typing here...">

        <div class="controls">
            <button class="button primary" id="restart-button">Restart Test</button>
            <button class="button secondary" id="settings-button">Settings</button>
        </div>

        <div class="result-modal" id="result-modal">
            <div class="modal-content">
                <h2>Test Results</h2>
                <div class="stats">
                    <div class="stat-item">
                        <h3>Final Speed (WPM)</h3>
                        <p id="final-wpm" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final Accuracy (%)</h3>
                        <p id="final-accuracy" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Total Errors</h3>
                        <p id="final-errors" class="result-value-red">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Raw WPM</h3>
                        <p id="raw-wpm" class="result-value-purple">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final CPM</h3>
                        <p id="final-cpm" class="result-value-orange">0</p>
                    </div>
                    <div class="stat-item target-status" id="wpm-target-status">
                        <h3>WPM Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                    <div class="stat-item target-status" id="accuracy-target-status">
                        <h3>Accuracy Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                </div>
                <button class="button primary" id="modal-restart-button">Restart Test</button>
                <button class="button secondary" id="modal-settings-button">New Test with Settings</button>
            </div>
        </div>
    </div>

    <script>
        // Function to fetch AI-generated stories (simulated for now)
        async function fetchAIGeneratedStory(lengthCategory = 'medium') {
            // In a real application, this would be an API call to your backend
            // For GitHub Pages, you'd need to deploy a backend (e.g., on Render)
            // and replace this with your actual API endpoint.
            // Example: const response = await fetch('YOUR_BACKEND_API_ENDPOINT/generate-story', {
            //    method: 'POST',
            //    headers: { 'Content-Type': 'application/json' },
            //    body: JSON.stringify({ length: lengthCategory })
            // });
            // const data = await response.json();
            // return data.story;

            // --- MOCK AI GENERATION FOR FRONTEND ONLY ---
            // Since we can't run real AI on GitHub Pages without a backend,
            // we'll simulate it by picking a longer random passage from a predefined list.
            const longStories = [
                "In a quaint village nestled between rolling hills and a winding river, lived a curious young inventor named Elara. Her days were spent tinkering with gears, wires, and strange contraptions in her small, cluttered workshop. The villagers often chuckled at her eccentricities, but they also secretly admired her unwavering dedication. One day, a fierce storm swept through the valley, knocking out power and isolating the village. Elara, with a twinkle in her eye, knew this was her moment to shine. She unveiled her latest invention: a device that could harness the raw energy of the storm itself, providing light and warmth to every home. With a flick of a switch, the village square lit up, casting a warm glow that banished the darkness and brought hope to the hearts of the people. From that day forward, Elara was no longer just a curious inventor; she was their beacon of light.\n\nShe continued her work, always striving to improve her creations. The villagers, once skeptical, now sought her advice and marvelled at her ingenuity. Elara taught them about sustainable energy and the importance of innovation. Her workshop became a hub of learning, where children gathered to watch her work and ask questions. The village, once known only for its quiet charm, became a symbol of progress and self-sufficiency, all thanks to Elara's relentless pursuit of knowledge and her generous spirit. The legacy of her inventions spread far beyond the valley, inspiring other communities to embrace a future powered by clean, renewable sources. Her story became a testament to the power of one individual to change the world.",
                "The ancient library was a labyrinth of forgotten knowledge, its shelves stretching towards a vaulted ceiling, filled with books bound in leather and imbued with the scent of aged paper. Maya, an aspiring historian, had always dreamed of uncovering its secrets. Legend spoke of a hidden chamber, accessible only to those who could decipher the riddles woven into the very architecture of the building. Armed with a dusty map and her keen intellect, Maya spent weeks tracing symbols and solving puzzles, her fingers trailing over forgotten inscriptions. Finally, a section of the wall receded with a soft click, revealing a spiral staircase descending into darkness. Below, she found not gold or jewels, but a single, illuminated tome, its pages filled with the true history of their world, a history far grander and more intricate than any she had ever read.\n\nThe tome detailed ancient civilizations and their rise and fall, the forgotten technologies they wielded, and the philosophies that guided their lives. It wasn't merely a record of events, but a deep exploration of human nature itself. Maya realized the immense responsibility of this discovery. She dedicated her life to transcribing and disseminating its contents, ensuring that the knowledge would never again be lost to time. Her efforts sparked a new age of enlightenment, and humanity, armed with the wisdom of the past, began to build a better future.",
                "The city of Neo-Veridia hummed with the silent thrum of hover-cars and the glow of holographic advertisements. Humans and advanced AI lived side-by-side, their lives intertwined in a complex dance of technology and tradition. Kael, a data archivist, spent his days sifting through digital remnants of the past, seeking patterns and anomalies. One evening, he stumbled upon a peculiar data stream ‚Äì an encrypted message from an unknown source, speaking of a long-lost natural world, untouched by urbanization. Driven by an insatiable curiosity, Kael followed the digital breadcrumbs, leading him to an ancient, forgotten port where a single, dilapidated spacecraft awaited. It was a journey into the unknown, a quest to find the whispered legends of green forests, blue oceans, and the untamed beauty of a world before concrete and chrome."
            ];
            const shortStories = [
                "The cat slept soundly by the fire, purring softly. A gentle rain fell outside, tapping on the windowpane. Soon, morning light would fill the room, waking the house. Life was simple and good.",
                "A tiny seed lay buried deep in the earth, dreaming of the sun. Slowly, it pushed a root down and a sprout up. Green leaves unfurled, reaching for the sky. It grew into a strong oak tree.",
                "The old lighthouse stood tall against the stormy sea, its beam cutting through the fog. For generations, it guided ships safely to shore. A silent guardian, it watched over the waves.",
                "She picked up her brush and dabbed paint onto the canvas. Colors swirled, forming landscapes and dreams. Each stroke brought a new world to life, born from her imagination and skill."
            ];
            const randomWordList = [
                "the", "quick", "brown", "fox", "jumps", "over", "lazy", "dog", "typing", "practice", "keyboard", "speed", "accuracy", "challenge", "learn", "javascript", "html", "css", "web", "development", "program", "computer", "science", "internet", "browser", "editor", "function", "variable", "element", "document", "style", "console", "terminal", "algorithm", "data", "structure", "network", "server", "client", "request", "response", "protocol", "security", "encryption", "database", "query", "framework", "library", "component", "module", "package", "version", "control", "repository", "commit", "branch", "merge", "pull", "push", "remote", "local", "online", "offline", "connect", "disconnect", "upload", "download", "install", "update", "delete", "create", "read", "write", "execute", "debug", "test", "deploy", "monitor", "optimize", "scale", "automate", "build", "run", "stop", "start", "restart", "configure", "setup", "manage", "organize", "design", "develop", "implement", "maintain", "support", "troubleshoot", "resolve", "solution", "problem", "issue", "error", "warning", "success", "failure", "progress", "status", "report", "log", "history", "analytics", "metric", "performance", "resource", "memory", "cpu", "disk", "bandwidth", "latency", "throughput", "reliability", "availability", "scalability", "maintainability", "usability", "flexibility", "extensibility", "portability", "security", "integrity", "confidentiality", "authentication", "authorization", "audit", "compliance", "regulation", "standard", "guideline", "best", "practice", "pattern", "design", "architecture", "model", "diagram", "flowchart", "pseudocode", "documentation", "comment", "refactor", "optimize", "debug", "test", "deploy", "monitor", "alert", "log", "trace", "profile", "benchmark", "analysis", "report", "summary", "detail", "overview", "context", "scope", "requirement", "specification", "feature", "bug", "fix", "patch", "release", "version", "update", "upgrade", "downgrade", "install", "uninstall", "setup", "configure", "customize", "personalize", "settings", "options", "preferences", "profile", "account", "user", "admin", "guest", "role", "permission", "access", "control", "security", "privacy", "data", "information", "knowledge", "wisdom", "intelligence", "learning", "education", "training", "course", "lesson", "tutorial", "guide", "manual", "book", "article", "blog", "forum", "community", "support", "help", "faq", "troubleshoot", "debug", "solve", "resolve", "fix", "repair", "restore", "backup", "recover", "archive", "compress", "decompress", "encrypt", "decrypt", "hash", "checksum", "validate", "verify", "authenticate", "authorize", "grant", "revoke", "deny", "allow", "enable", "disable", "toggle", "switch", "activate", "deactivate", "start", "stop", "pause", "resume", "cancel", "abort", "retry", "redo", "undo", "save", "load", "open", "close", "new", "edit", "delete", "copy", "cut", "paste", "select", "all", "clear", "reset", "submit", "send", "receive", "download", "upload", "import", "export", "share", "print", "preview", "zoom", "in", "out", "fit", "width", "height", "actual", "size", "fullscreen", "exit", "search", "filter", "sort", "group", "categorize", "tag", "label", "mark", "favorite", "bookmark", "pin", "hide", "show", "collapse", "expand", "move", "rename", "duplicate", "clone", "merge", "split", "join", "combine", "separate", "extract", "insert", "remove", "replace", "find", "replace", "goto", "line", "column", "character", "word", "sentence", "paragraph", "document", "file", "folder", "directory", "path", "url", "uri", "urn", "protocol", "host", "port", "query", "fragment", "scheme", "authority", "userinfo", "hostname", "pathname", "search", "hash", "origin", "protocol", "domain", "subdomain", "top-level", "second-level", "country-code", "generic", "reserved", "public", "private", "local", "global", "internal", "external", "remote", "cloud", "on-premise", "hybrid", "distributed", "centralized", "decentralized", "peer-to-peer", "client-server", "front-end", "back-end", "full-stack", "desktop", "mobile", "web", "native", "cross-platform", "hybrid", "responsive", "adaptive", "fluid", "fixed", "grid", "flexbox", "bootstrap", "material", "design", "ui", "ux", "interface", "experience", "interaction", "usability", "accessibility", "performance", "security", "scalability", "reliability", "availability", "maintainability", "usability", "flexibility", "extensibility", "portability", "security", "integrity", "confidentiality", "authentication", "authorization", "audit", "compliance", "regulation", "standard", "guideline", "best", "practice", "pattern", "design", "architecture", "model", "diagram", "flowchart", "pseudocode", "documentation", "comment", "refactor", "optimize", "debug", "test", "deploy", "monitor", "alert", "log", "trace", "profile", "benchmark", "analysis", "report", "summary", "detail", "overview", "context", "scope", "requirement", "specification", "feature", "bug", "fix", "patch", "release", "version", "update", "upgrade", "downgrade", "install", "uninstall", "setup", "configure", "customize", "personalize", "settings", "options", "preferences", "profile", "account", "user", "admin", "guest", "role", "permission", "access", "control", "security", "privacy", "data", "information", "knowledge", "wisdom", "intelligence", "learning", "education", "training", "course", "lesson", "tutorial", "guide", "manual", "book", "article", "blog", "forum", "community", "support", "help", "faq", "troubleshoot", "debug", "solve", "resolve", "fix", "repair", "restore", "backup", "recover", "archive", "compress", "decompress", "encrypt", "decrypt", "hash", "checksum", "validate", "verify", "authenticate", "authorize", "grant", "revoke", "deny", "allow", "enable", "disable", "toggle", "switch", "activate", "deactivate", "start", "stop", "pause", "resume", "cancel", "abort", "retry", "redo", "undo", "save", "load", "open", "close", "new", "edit", "delete", "copy", "cut", "paste", "select", "all", "clear", "reset", "submit", "send", "receive", "download", "upload", "import", "export", "share", "print", "preview", "zoom", "in", "out", "fit", "width", "height", "actual", "size", "fullscreen", "exit", "search", "filter", "sort", "group", "categorize", "tag", "label", "mark", "favorite", "bookmark", "pin", "hide", "show", "collapse", "expand", "move", "rename", "duplicate", "clone", "merge", "split", "join", "combine", "separate", "extract", "insert", "remove", "replace", "find", "replace", "goto", "line", "column", "character", "word", "sentence", "paragraph", "document", "file", "folder", "directory", "path", "url", "uri", "urn", "protocol", "host", "port", "query", "fragment", "scheme", "authority", "userinfo", "hostname", "pathname", "search", "hash", "origin", "protocol", "domain", "subdomain", "top-level", "second-level", "country-code", "generic", "reserved", "public", "private", "local", "global", "internal", "external", "remote", "cloud", "on-premise", "hybrid", "distributed", "centralized", "decentralized", "peer-to-peer", "client-server", "front-end", "back-end", "full-stack", "desktop", "mobile", "web", "native", "cross-platform", "hybrid", "responsive", "adaptive", "fluid", "fixed", "grid", "flexbox", "bootstrap", "material", "design", "ui", "ux", "interface", "experience", "interaction", "usability", "accessibility", "performance", "security", "scalability", "reliability", "availability", "maintainability", "testability", "extensibility", "flexibility", "portability", "reusability", "modularity", "simplicity", "consistency", "efficiency", "robustness", "error-handling", "logging", "monitoring", "debugging", "testing", "deployment", "automation", "scripting", "programming", "coding", "software", "hardware", "firmware", "middleware", "operating", "system", "kernel", "shell", "command", "line", "interface", "graphical", "user", "interface", "api", "sdk", "library", "framework", "tool", "utility", "application", "program", "service", "daemon", "process", "thread", "concurrency", "parallelism", "synchronization", "asynchronous", "callback", "promise", "async", "await", "event", "loop", "queue", "stack", "heap", "tree", "graph", "linked", "list", "array", "object", "map", "set", "iterator", "generator", "decorator", "closure", "higher-order", "function", "pure", "function", "side-effect", "idempotent", "immutable", "mutable", "state", "stateless", "stateful", "component", "props", "state", "lifecycle", "hook", "context", "provider", "consumer", "reducer", "action", "dispatch", "store", "subscribe", "unsubscribe", "middleware", "thunk", "saga", "redux", "mobx", "vuex", "angular", "react", "vue", "jquery", "lodash", "underscore", "moment", "date-fns", "axios", "fetch", "websocket", "socket.io", "graphql", "rest", "api", "json", "xml", "yaml", "csv", "tsv", "markdown", "html", "css", "javascript", "typescript", "python", "java", "csharp", "go", "rust", "php", "ruby", "swift", "kotlin", "scala", "haskell", "clojure", "lisp", "erlang", "elixir", "perl", "bash", "shell", "powershell", "sql", "nosql", "mongodb", "postgresql", "mysql", "sqlite", "redis", "cassandra", "elasticsearch", "kafka", "rabbit", "mq", "aws", "azure", "gcp", "docker", "kubernetes", "git", "github", "gitlab", "bitbucket", "jenkins", "travis", "ci", "circleci", "github", "actions", "azure", "devops", "jira", "trello", "asana", "slack", "discord", "zoom", "google", "meet", "microsoft", "teams", "outlook", "gmail", "calendar", "drive", "docs", "sheets", "slides", "forms", "maps", "youtube", "twitter", "facebook", "instagram", "linkedin", "snapchat", "tiktok", "reddit", "pinterest", "whatsapp", "telegram", "signal", "viber", "wechat", "line", "skype", "facetime", "imessage", "sms", "email", "phone", "call", "video", "audio", "text", "message", "chat", "group", "channel", "thread", "notification", "alert", "badge", "icon", "button", "link", "input", "text", "area", "checkbox", "radio", "select", "option", "dropdown", "slider", "range", "progress", "bar", "spinner", "loader", "tooltip", "popover", "modal", "dialog", "accordion", "tabs", "carousel", "pagination", "breadcrumb", "navbar", "sidebar", "footer", "header", "main", "section", "article", "aside", "figure", "figcaption", "details", "summary", "dialog", "menu", "item", "list", "unordered", "ordered", "definition", "table", "row", "column", "cell", "caption", "thead", "tbody", "tfoot", "form", "fieldset", "legend", "label", "input", "textarea", "button", "select", "option", "datalist", "output", "meter", "progress", "img", "picture", "source", "svg", "canvas", "audio", "video", "track", "embed", "iframe", "object", "param", "map", "area", "link", "meta", "style", "script", "noscript", "template", "slot", "abbr", "address", "b", "bdi", "bdo", "blockquote", "cite", "code", "del", "dfn", "em", "i", "ins", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "acronym", "applet", "basefont", "big", "center", "dir", "font", "frame", "frameset", "noframes", "strike", "tt"
            ];
            // If random-words is selected, we combine words to form a longer story for variety
            if (lengthCategory === 'random-words') {
                let generatedText = "";
                // Increase base word count to ensure enough text for longer durations
                const baseWordCount = 300; 
                const targetWordCount = baseWordCount * (testDurationSelect.value / 5); 
                for (let i = 0; i < targetWordCount; i++) {
                    generatedText += randomWordList[Math.floor(Math.random() * randomWordList.length)] + " ";
                }
                return generatedText.trim();
            } else if (lengthCategory === 'short') {
                return shortStories[Math.floor(Math.random() * shortStories.length)];
            } else if (lengthCategory === 'long') {
                return longStories[Math.floor(Math.random() * longStories.length)];
            } else { // 'medium' or default AI story fallback
                return "The sun dipped below the horizon, painting the sky in hues of orange and purple. A lone bird soared across the fading light, its wings catching the last rays. Below, the city lights began to twinkle, promising a night of bustling activity. A gentle breeze carried the scent of blooming jasmine through the open window. It was a perfect evening to reflect on the day's events and anticipate the quiet hours ahead. The world felt at peace, a symphony of subtle changes unfolding as darkness embraced the landscape, bringing with it the promise of a new dawn and fresh opportunities. Every moment held a quiet beauty, a fleeting perfection that made the heart sing with gratitude for its simple existence.";
            }
        }
        // --- END MOCK AI GENERATION ---

        // DOM Elements
        const mainContent = document.getElementById('main-content');
        const testArea = document.getElementById('test-area');
        const typingInput = document.getElementById('typing-input');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const errorsDisplay = document.getElementById('errors');
        const cpmDisplay = document.getElementById('cpm'); // New CPM display
        const countdownDisplay = document.getElementById('countdown');
        const restartButton = document.getElementById('restart-button');
        const settingsButton = document.getElementById('settings-button');
        const resultModal = document.getElementById('result-modal');
        const finalWpmDisplay = document.getElementById('final-wpm');
        const finalAccuracyDisplay = document.getElementById('final-accuracy');
        const finalErrorsDisplay = document.getElementById('final-errors');
        const rawWpmDisplay = document.getElementById('raw-wpm');
        const finalCpmDisplay = document.getElementById('final-cpm'); // New Final CPM display
        const modalRestartButton = document.getElementById('modal-restart-button');
        const modalSettingsButton = document.getElementById('modal-settings-button');

        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settings-overlay');
        const testDurationSelect = document.getElementById('test-duration');
        const targetWpmInput = document.getElementById('target-wpm');
        const targetAccuracyInput = document.getElementById('target-accuracy');
        const storyTypeSelect = document.getElementById('story-type');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const skipSettingsButton = document.getElementById('skip-settings-button');
        const wpmTargetStatus = document.getElementById('wpm-target-status');
        const accuracyTargetStatus = document.getElementById('accuracy-target-status');

        // New Custom Story Elements
        const customStoryArea = document.getElementById('custom-story-area');
        const customStoryTextarea = document.getElementById('custom-story-textarea');
        const addStoryLinkButton = document.getElementById('add-story-link-button');

        // Global Variables
        let testWords = []; // This array will hold the expected words and '\n' markers
        let wordIndex = 0;
        let charIndex = 0; // Current character index within the current word
        let startTime;
        let timerInterval;
        let defaultTestDuration = 5 * 60; // Default 5 minutes in seconds
        let timeLeft = defaultTestDuration;
        let correctChars = 0; // Correct characters typed (for WPM/CPM)
        let incorrectChars = 0; // Incorrect characters typed
        let typedCharsOverall = 0; // Total characters user has attempted to type (including correct and incorrect)

        let userTargetWPM = null;
        let userTargetAccuracy = null;
        let currentStoryType = 'random-words'; // Default story type
        let customStoryText = ''; // Stores user's custom story

        // Utility to format time
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        async function generateAndRenderTestWords() {
            testWords = []; // Reset words for typing logic
            testArea.innerHTML = ''; // Clear previous content

            let textToType = "";

            if (currentStoryType === 'ai-story') {
                let lengthCategory = 'medium'; // Default for AI story
                const durationMinutes = parseInt(testDurationSelect.value);
                if (durationMinutes <= 2) {
                    lengthCategory = 'short';
                } else if (durationMinutes >= 10) {
                    lengthCategory = 'long';
                }
                textToType = await fetchAIGeneratedStory(lengthCategory);
            } else if (currentStoryType === 'user-custom') {
                textToType = customStoryText.trim();
                if (textToType === "") {
                    alert("Please paste your custom story in the text area or select another story type.");
                    settingsOverlay.classList.add('show');
                    mainContent.classList.add('content-hidden');
                    return false; // Indicate failure to generate
                }
            } else { // random-words
                textToType = await fetchAIGeneratedStory('random-words');
            }

            // Process text to handle paragraphs and line breaks
            // Split by any newline sequence (CRLF, LF, CR)
            const paragraphs = textToType.split(/\r?\n/); 

            paragraphs.forEach((paragraphText, paraIdx) => {
                const paragraphDiv = document.createElement('div');
                paragraphDiv.classList.add('paragraph');

                // Split words in a paragraph by one or more spaces
                const wordsInParagraph = paragraphText.split(/\s+/).filter(word => word.length > 0);

                wordsInParagraph.forEach((word, wordIdxInPara) => {
                    testWords.push(word); // Add word to our global testWords array

                    const wordSpan = document.createElement('span');
                    wordSpan.classList.add('word');
                    word.split('').forEach(char => {
                        const charSpan = document.createElement('span');
                        charSpan.textContent = char;
                        charSpan.classList.add('untyped');
                        wordSpan.appendChild(charSpan);
                    });
                    paragraphDiv.appendChild(wordSpan);
                });

                // Add a visual newline marker and corresponding testWords entry for actual newlines
                // This means testWords will contain actual words or the special '\n' string.
                if (paraIdx < paragraphs.length -1) { // If it's not the last paragraph
                    // Create a visual newline marker element
                    const newlineMarker = document.createElement('span');
                    newlineMarker.classList.add('newline-marker');
                    paragraphDiv.appendChild(newlineMarker);
                    
                    testWords.push('\n'); // Special indicator for newline in testWords array
                }
                
                testArea.appendChild(paragraphDiv);
            });
            
            highlightCurrentWord();
            adjustTestAreaScroll();
            return true; // Indicate successful generation
        }

        // This function retrieves the DOM span element for a specific "word" or newline marker in testWords
        function getDomElementForTestItem(targetIndex) {
            let currentTraversalIndex = 0;
            const paragraphs = testArea.querySelectorAll('.paragraph');

            for (let i = 0; i < paragraphs.length; i++) {
                const paragraphDiv = paragraphs[i];
                const children = Array.from(paragraphDiv.children); // Get all direct children (words or newline markers)

                for (let j = 0; j < children.length; j++) {
                    const child = children[j];
                    if (currentTraversalIndex === targetIndex) {
                        return child;
                    }
                    currentTraversalIndex++;
                }
            }
            return null; // Element not found
        }

        function highlightCurrentWord() {
            // Remove highlighting from all words and newline markers first
            testArea.querySelectorAll('.word').forEach(span => {
                span.classList.remove('current-word');
            });
            testArea.querySelectorAll('.newline-marker').forEach(marker => {
                marker.classList.remove('current-newline-marker');
            });


            if (wordIndex >= testWords.length) {
                adjustTestAreaScroll(); // Still adjust scroll if needed at the end
                return;
            }

            const currentItem = testWords[wordIndex];
            const currentDomElement = getDomElementForTestItem(wordIndex);

            if (currentItem === '\n') {
                if (currentDomElement && currentDomElement.classList.contains('newline-marker')) {
                    currentDomElement.classList.add('current-newline-marker');
                    adjustTestAreaScroll();
                }
            } else if (currentDomElement && currentDomElement.classList.contains('word')) {
                currentDomElement.classList.add('current-word');
                adjustTestAreaScroll();
            }
        }

        // Function to automatically scroll the test area
        function adjustTestAreaScroll() {
            const currentDomElement = getDomElementForTestItem(wordIndex);
            if (!currentDomElement) return;

            const testAreaRect = testArea.getBoundingClientRect();
            const targetRect = currentDomElement.getBoundingClientRect();

            // Calculate vertical scroll
            // If the target element's bottom is below the test area's visible bottom
            if (targetRect.bottom > testAreaRect.bottom) {
                testArea.scrollTop += (targetRect.bottom - testAreaRect.bottom) + 10; // Scroll down by diff + a little buffer
            }
            // If the target element's top is above the test area's visible top
            else if (targetRect.top < testAreaRect.top) {
                testArea.scrollTop -= (testAreaRect.top - targetRect.top) + 10; // Scroll up by diff + a little buffer
            }
        }

        function updateStats() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            if (timeElapsed === 0) {
                cpmDisplay.textContent = 0;
                wpmDisplay.textContent = 0;
                accuracyDisplay.textContent = 0;
                errorsDisplay.textContent = incorrectChars;
                return; // Avoid division by zero at start
            }

            const minutesElapsed = timeElapsed / 60;

            // WPM calculation: (Correct Words / Time in Minutes)
            // A "word" is often defined as 5 characters including spaces.
            const currentWPM = Math.round((correctChars / 5) / minutesElapsed);
            wpmDisplay.textContent = isNaN(currentWPM) ? 0 : currentWPM;

            // CPM calculation: Total Correct Characters / (Time in Minutes)
            const currentCPM = Math.round(correctChars / minutesElapsed);
            cpmDisplay.textContent = isNaN(currentCPM) ? 0 : currentCPM;

            const currentAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            accuracyDisplay.textContent = isNaN(currentAccuracy) ? 0 : currentAccuracy;
            errorsDisplay.textContent = incorrectChars;
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = formatTime(timeLeft);
                updateStats();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endTest();
                }
            }, 1000);
        }

        function endTest() {
            typingInput.disabled = true;
            typingInput.value = '';
            clearInterval(timerInterval);
            updateStats(); // Final update

            const timeElapsed = (defaultTestDuration - timeLeft);
            const finalMinutesElapsed = timeElapsed / 60;

            // Handle potential division by zero if test ended immediately for some reason
            const finalWPM = finalMinutesElapsed > 0 ? Math.round((correctChars / 5) / finalMinutesElapsed) : 0;
            const finalAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            const finalRawWPM = finalMinutesElapsed > 0 ? Math.round((typedCharsOverall / 5) / finalMinutesElapsed) : 0;
            const finalCPM = finalMinutesElapsed > 0 ? Math.round(correctChars / finalMinutesElapsed) : 0;


            finalWpmDisplay.textContent = isNaN(finalWPM) ? 0 : finalWPM;
            finalAccuracyDisplay.textContent = isNaN(finalAccuracy) ? 0 : finalAccuracy;
            finalErrorsDisplay.textContent = incorrectChars;
            rawWpmDisplay.textContent = isNaN(finalRawWPM) ? 0 : finalRawWPM;
            finalCpmDisplay.textContent = isNaN(finalCPM) ? 0 : finalCPM; // Set Final CPM

            // Add color to final results
            finalWpmDisplay.className = 'result-value-green';
            finalAccuracyDisplay.className = 'result-value-green';
            finalErrorsDisplay.className = 'result-value-red'; // Errors are bad, so red
            rawWpmDisplay.className = 'result-value-purple';
            finalCpmDisplay.className = 'result-value-orange';


            // Check and update target status
            if (userTargetWPM !== null && !isNaN(userTargetWPM)) {
                if (finalWPM >= userTargetWPM) {
                    wpmTargetStatus.querySelector('p').textContent = `Met (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    wpmTargetStatus.querySelector('p').textContent = `Missed (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                wpmTargetStatus.querySelector('p').textContent = 'N/A';
                wpmTargetStatus.querySelector('p').className = 'status-neutral';
            }

            if (userTargetAccuracy !== null && !isNaN(userTargetAccuracy)) {
                if (finalAccuracy >= userTargetAccuracy) {
                    accuracyTargetStatus.querySelector('p').textContent = `Met (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    accuracyTargetStatus.querySelector('p').textContent = `Missed (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                accuracyTargetStatus.querySelector('p').textContent = 'N/A';
                accuracyTargetStatus.querySelector('p').className = 'status-neutral';
            }

            resultModal.classList.add('show');
            // Allow restart and settings access after test ends
            restartButton.disabled = false;
            settingsButton.disabled = false;
        }

        async function initializeTest(duration, targetWPM, targetAccuracy, storyType, customText = '') {
            clearInterval(timerInterval);
            defaultTestDuration = duration * 60; // Convert minutes to seconds
            timeLeft = defaultTestDuration;
            countdownDisplay.textContent = formatTime(timeLeft);
            wordIndex = 0;
            charIndex = 0; // Reset charIndex for new word
            correctChars = 0;
            incorrectChars = 0;
            typedCharsOverall = 0;
            typingInput.value = '';
            typingInput.disabled = false;
            startTime = null; // Reset start time
            
            userTargetWPM = targetWPM ? parseInt(targetWPM) : null;
            userTargetAccuracy = targetAccuracy ? parseInt(targetAccuracy) : null;
            currentStoryType = storyType;
            customStoryText = customText; // Set custom story if provided

            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '0';
            errorsDisplay.textContent = '0';
            cpmDisplay.textContent = '0'; // Reset CPM display

            // Ensure buttons are clickable for a new test or settings
            restartButton.disabled = false; 
            settingsButton.disabled = false;
            
            // Generate words and check if successful (e.g., custom story not empty)
            const generationSuccess = await generateAndRenderTestWords();
            if (!generationSuccess) {
                // If story generation failed (e.g., empty custom story), do not proceed
                return;
            }

            typingInput.focus();
            resultModal.classList.remove('show');
            settingsOverlay.classList.remove('show'); // Hide settings overlay
            mainContent.classList.remove('content-hidden'); // Show main content
        }


        // Event Listeners

        // Input event for general character typing and visual feedback
        typingInput.addEventListener('input', (e) => {
            if (!startTime) {
                startTimer(); // Start timer on first input
            }
            
            const currentExpectedItem = testWords[wordIndex];
            const typedText = e.target.value;

            // If we are currently at a newline marker, prevent typing anything
            if (currentExpectedItem === '\n') {
                typingInput.value = ''; // Clear input immediately
                // User must press Enter for newline
                return; 
            }

            const currentWordExpected = currentExpectedItem; 
            const currentWordSpan = getDomElementForTestItem(wordIndex); 

            if (!currentWordSpan || !currentWordSpan.classList.contains('word')) { 
                // This means currentExpectedItem is not a word (e.g., it's a newline marker, or end of test)
                // This case should ideally be handled by keydown for Space/Enter
                return;
            }

            const charSpans = Array.from(currentWordSpan.querySelectorAll('span')); // Get all character spans within the word

            // Reset all spans in current word to untyped and remove correctness classes
            charSpans.forEach(span => {
                span.classList.remove('correct', 'incorrect', 'extra');
                span.classList.add('untyped');
                span.style.display = 'inline'; // Ensure they are visible
            });

            // Update char rendering within the current word
            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                const charSpan = charSpans[i];

                if (charSpan) {
                    if (typedChar === undefined) {
                        charSpan.classList.add('untyped');
                    } else if (typedChar.toLowerCase() === charExpected.toLowerCase()) { // Case-insensitive comparison
                        charSpan.classList.add('correct');
                    } else {
                        charSpan.classList.add('incorrect');
                    }
                }
            }

            // Handle extra characters typed (beyond the current word's length)
            // First, remove any existing extra spans
            currentWordSpan.querySelectorAll('.extra').forEach(el => el.remove());

            // Then, create and add new extra chars
            if (typedText.length > currentWordExpected.length) {
                for (let i = currentWordExpected.length; i < typedText.length; i++) {
                    const extraSpan = document.createElement('span');
                    extraSpan.textContent = typedText[i];
                    extraSpan.classList.add('extra');
                    currentWordSpan.appendChild(extraSpan);
                }
            }
            updateStats();
        });


        // Keydown event for Space and Enter
        typingInput.addEventListener('keydown', (e) => {
            if (!startTime) {
                startTimer();
            }

            const currentExpectedItem = testWords[wordIndex];
            const typedText = typingInput.value;

            if (e.key === ' ') { // Handle Spacebar
                e.preventDefault(); // Prevent adding space to input box manually

                // If currently at a newline marker, hitting space is an error
                if (currentExpectedItem === '\n') {
                    incorrectChars++;
                    typedCharsOverall++;
                    typingInput.value = ''; // Clear input
                    updateStats();
                    return; 
                }
                
                const currentWordExpected = currentExpectedItem;
                let wordTyped = typedText.trim(); // Get the typed word without trailing space

                let tempCorrectCharsForWord = 0;
                let tempIncorrectCharsForWord = 0;

                // Compare typed word character by character with expected word
                for (let i = 0; i < currentWordExpected.length; i++) {
                    if (wordTyped[i] && wordTyped[i].toLowerCase() === currentWordExpected[i].toLowerCase()) {
                        tempCorrectCharsForWord++;
                    } else if (wordTyped[i]) { // Typed something, but it's incorrect
                        tempIncorrectCharsForWord++;
                    } else { // Missed character (not typed)
                        tempIncorrectCharsForWord++;
                    }
                }
                // Account for extra characters typed beyond the expected word
                if (wordTyped.length > currentWordExpected.length) {
                    tempIncorrectCharsForWord += (wordTyped.length - currentWordExpected.length);
                }
                
                correctChars += tempCorrectCharsForWord;
                incorrectChars += tempIncorrectCharsForWord;
                typedCharsOverall += wordTyped.length; // Count actual chars typed for the word
                typedCharsOverall++; // Also count the space itself as one typed character for overall calculations

                wordIndex++; // Move to next item (word or newline)
                typingInput.value = ''; // Clear input for next word
                highlightCurrentWord(); // Update highlighting and scroll

                if (wordIndex >= testWords.length) { // End test if all words/newlines are typed
                    endTest();
                }
                updateStats();

            } else if (e.key === 'Enter') { // Handle Enter key
                e.preventDefault(); // Prevent default Enter behavior (new line in input box)

                // If we are currently at a newline marker, and the input box is empty (or only whitespace)
                if (currentExpectedItem === '\n') {
                    // If anything was typed in the box before hitting Enter for a newline, it's an error.
                    if (typedText.trim().length > 0) {
                        incorrectChars += typedText.trim().length;
                        typedCharsOverall += typedText.trim().length;
                    }

                    correctChars++; // Count the newline itself as one correct char
                    typedCharsOverall++; // Count the newline as one typed char

                    wordIndex++; // Move past the '\n' "word"
                    typingInput.value = ''; // Clear input
                    highlightCurrentWord(); // Re-highlight (moves to next actual word)

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                } else {
                    // If Enter is pressed but we are NOT expecting a newline, it's an error
                    incorrectChars++; // Count this Enter as an error
                    typedCharsOverall++; // Count this Enter as a typed character
                    // Optionally: flash a red background or play an error sound
                    // For now, just count the error.
                }
                updateStats();
            } else if (e.key === 'Backspace') {
                // 'input' event handles visual feedback for backspace.
                // No need to adjust correctChars/incorrectChars here directly on keydown,
                // as 'input' listener will recalculate based on new input.value.
            }
        });


        restartButton.addEventListener('click', () => {
            // Show settings overlay on restart
            settingsOverlay.classList.add('show');
            resultModal.classList.remove('show'); // Hide result modal if open
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly on re-opening settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        settingsButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        saveSettingsButton.addEventListener('click', async () => {
            const duration = parseInt(testDurationSelect.value);
            const targetWPM = targetWpmInput.value;
            const targetAccuracy = targetAccuracyInput.value;
            const storyType = storyTypeSelect.value;
            let storyContent = '';

            if (storyType === 'user-custom') {
                storyContent = customStoryTextarea.value.trim();
            }
            await initializeTest(duration, targetWPM, targetAccuracy, storyType, storyContent);
        });

        skipSettingsButton.addEventListener('click', async () => {
            await initializeTest(5, null, null, 'random-words'); // Default to 5 mins, no targets, random words
        });

        modalRestartButton.addEventListener('click', async () => {
            await initializeTest(defaultTestDuration / 60, userTargetWPM, userTargetAccuracy, currentStoryType, customStoryText); // Use current settings for restart
        });

        modalSettingsButton.addEventListener('click', () => {
            resultModal.classList.remove('show');
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for Story Type dropdown to show/hide custom story area
        storyTypeSelect.addEventListener('change', () => {
            if (storyTypeSelect.value === 'user-custom') {
                customStoryArea.style.display = 'block';
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for "Add Story from Reedsy" button
        addStoryLinkButton.addEventListener('click', () => {
            window.open('https://blog.reedsy.com/short-stories/', '_blank');
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            settingsOverlay.classList.add('show');
            // Hide main content initially
            mainContent.classList.add('content-hidden');
            countdownDisplay.textContent = formatTime(defaultTestDuration); // Show initial default time
            // Ensure custom story area is hidden initially
            customStoryArea.style.display = 'none';
        });

    </script>
</body>
</html>
