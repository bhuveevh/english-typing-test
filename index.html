<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced English Typing Test (Single File)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Source+Code+Pro:wght@400;700&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Font Imports */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #e3f2fd; /* Light Blue background */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align at the top */
            min-height: 100vh;
            padding: 20px;
            background: linear-gradient(to right, #e3f2fd, #fce4ec); /* Light Blue to Light Pink Gradient */
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15); /* More prominent shadow */
            width: 100%;
            max-width: 900px;
            animation: fadeIn 0.8s ease-out;
            border: 1px solid #bbdefb; /* Light blue border */
            position: relative; /* For z-index to work with settings overlay */
            z-index: 1; /* Ensure container is above other elements when settings are hidden */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            text-align: center;
            color: #e91e63; /* Pink primary color */
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5em; /* Larger title */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }

        /* Live Stats Area (moved to top) */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px; /* Space below stats */
            flex-wrap: wrap;
            gap: 15px;
            background-color: #fce4ec; /* Light pink background */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }

        .stat-item {
            background-color: #fff;
            padding: 12px 18px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            text-align: center;
            min-width: 120px;
            flex: 1;
            border: 1px solid #f8bbd0; /* Slightly darker pink border */
        }

        .stat-item h3 {
            color: #6a1b9a; /* Deep purple for sub-headers */
            font-size: 1em;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .stat-item p {
            font-size: 1.8em; /* Slightly smaller for compactness */
            font-weight: bold;
            color: #e91e63; /* Pink for values */
            font-family: 'Montserrat', sans-serif;
        }

        .timer-item p {
            color: #2196f3; /* Blue for timer */
        }
        
        /* New: Live CPM display style */
        .cpm-item p {
            color: #ff9800; /* Orange for CPM */
        }

        /* Test Area */
        .test-area {
            margin-bottom: 20px; /* Reduced margin */
            padding: 20px;
            background-color: #f1f8e9; /* Very light green for contrast */
            border-radius: 10px;
            border: 1px solid #dcedc8;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            min-height: 120px; /* Smaller height */
            max-height: 120px; /* Fixed height for 3 lines */
            overflow: hidden; /* Hide overflow */
            position: relative;
            line-height: 1.8; /* More spacing for readability */
            font-size: 1.2em; /* Slightly smaller font for more words per line */
            font-family: 'Open Sans', sans-serif; /* Changed to Open Sans for better readability */
            color: #444;
        }

        /* For handling paragraphs and line breaks in test-area */
        .paragraph {
            margin-bottom: 1.5em; /* Space between paragraphs */
            white-space: pre-wrap; /* Preserves whitespace and wraps text */
        }

        .word {
            display: inline-block;
            margin-right: 5px;
            padding: 1px 0;
            white-space: pre-wrap; /* Ensure words don't break mid-char for spaces */
        }

        .current-word {
            background-color: #fff9c4; /* Light yellow for current word */
            border-radius: 4px;
            padding: 1px 5px;
            box-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
        }

        .correct {
            color: #388e3c; /* Dark green for correct */
        }

        .incorrect {
            color: #d32f2f; /* Dark red for incorrect */
            text-decoration: underline wavy #d32f2f 2px;
        }

        .extra {
            color: #7b7b7b;
            background-color: #ffebee; /* Very light red background for extra */
            border-radius: 3px;
            padding: 0 2px;
        }

        .untyped {
            color: #7b7b7b;
        }

        /* Input Area */
        #typing-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.5em;
            border: 2px solid #ccc;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Source Code Pro', monospace; /* Kept monospace for input */
            background-color: #fcfcfc;
            margin-bottom: 20px; /* Space below input */
        }

        #typing-input:focus {
            border-color: #2196f3; /* Blue on focus */
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
        }

        /* Controls */
        .controls {
            text-align: center;
            margin-top: 20px; /* Reduced margin */
        }

        .button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px; /* Slightly more rounded buttons */
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            margin: 0 10px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
        }

        .button.primary {
            background-color: #e91e63; /* Pink primary */
            color: white;
            box-shadow: 0 4px 8px rgba(233, 30, 99, 0.2);
        }

        .button.primary:hover {
            background-color: #d81b60; /* Darker pink on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(233, 30, 99, 0.3);
        }

        .button.secondary {
            background-color: #2196f3; /* Blue secondary */
            color: white;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.2);
        }

        .button.secondary:hover {
            background-color: #1976d2; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(33, 150, 243, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Result Modal */
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .result-modal.show {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            max-width: 600px; /* Wider modal */
            width: 90%;
            border: 1px solid #bbdefb;
        }

        .result-modal.show .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            color: #e91e63;
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2em;
        }

        .modal-content .stats {
            flex-wrap: wrap; /* Ensure wrapping in modal too */
            justify-content: center;
            margin-bottom: 20px;
        }

        .modal-content .stat-item {
            margin-bottom: 15px;
            background-color: #e3f2fd; /* Light blue in modal stats */
            border: 1px solid #90caf9;
        }

        /* Result Colors */
        .result-value-green {
            color: #388e3c; /* Green for good results (WPM, Accuracy) */
        }
        .result-value-red {
            color: #d32f2f; /* Red for bad results (Errors) */
        }
        .result-value-orange {
            color: #ff9800; /* Orange for CPM */
        }
        .result-value-purple {
            color: #6a1b9a; /* Purple for Raw WPM */
        }


        .modal-content .button {
            margin-top: 25px;
            margin: 10px; /* Space between modal buttons */
        }

        /* Target Status in Modal */
        .stat-item.target-status p {
            font-size: 1.5em; /* Smaller font for target status */
        }
        .status-neutral { color: #607d8b; } /* Grey */
        .status-met { color: #388e3c; } /* Green */
        .status-not-met { color: #d32f2f; } /* Red */

        /* Settings Overlay (Full-screen) */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker, more opaque background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher z-index than container and result modal */
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.4s ease;
        }

        .settings-overlay.show {
            visibility: visible;
            opacity: 1;
        }

        .settings-overlay .settings-content {
            background-color: #f0f4c3; /* Light yellow-green for settings */
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            border: 1px solid #cddc39;
            transform: scale(0.9);
            transition: transform 0.4s ease;

            /* Fix for overflow on settings screen */
            max-height: 90vh; /* Limit height to 90% of viewport height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }

        .settings-overlay.show .settings-content {
            transform: scale(1);
        }

        .settings-overlay h2 {
            color: #4CAF50; /* Green for settings header */
            margin-bottom: 30px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2em;
        }

        .setting-group {
            margin-bottom: 25px; /* More space between groups */
            text-align: left;
        }

        .setting-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px; /* More space below label */
            color: #388e3c; /* Darker green for setting labels */
            font-size: 1.15em;
        }

        .setting-group select,
        .setting-group input[type="number"] {
            width: 100%;
            padding: 12px; /* Larger padding for inputs */
            border: 1px solid #aed581; /* Greenish border */
            border-radius: 8px;
            font-size: 1.1em;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Roboto', sans-serif;
        }

        .setting-group select:focus,
        .setting-group input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        /* New: Custom Story Area styles */
        #custom-story-area {
            display: none; /* Hidden by default */
            margin-top: 20px;
            border-top: 1px solid #cddc39;
            padding-top: 20px;
        }

        #custom-story-textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid #aed581;
            border-radius: 8px;
            font-size: 1.1em;
            font-family: 'Open Sans', sans-serif;
            resize: vertical;
            margin-bottom: 10px;
        }

        #custom-story-textarea:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        .custom-story-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .custom-story-controls .button {
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 48%; /* Adjust for spacing */
        }
        
        @media (max-width: 480px) {
            .custom-story-controls .button {
                max-width: 100%; /* Stack buttons on very small screens */
            }
        }


        .settings-overlay .button-group {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        /* Initial hidden state for the main content */
        .content-hidden {
            visibility: hidden;
            opacity: 0;
            height: 0;
            overflow: hidden;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            .stats {
                gap: 10px;
            }

            .stat-item {
                min-width: 100px;
                padding: 10px 12px;
            }

            .stat-item p {
                font-size: 1.5em;
            }

            .test-area {
                font-size: 1.1em;
                padding: 15px;
                min-height: 100px;
                max-height: 100px;
            }

            #typing-input {
                font-size: 1.2em;
                padding: 10px 15px;
            }

            .button {
                padding: 10px 20px;
                font-size: 1em;
                margin: 5px;
            }

            .modal-content {
                padding: 25px;
            }

            .modal-content h2 {
                font-size: 1.8em;
            }

            .settings-overlay .settings-content {
                padding: 25px;
            }
            .settings-overlay h2 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            .setting-group {
                margin-bottom: 20px;
            }
            .settings-overlay .button-group {
                flex-direction: column;
                gap: 15px;
            }
            .settings-overlay .button {
                width: 80%; /* Make buttons wider on small screens */
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <div class="settings-overlay" id="settings-overlay">
        <div class="settings-content">
            <h2>Typing Test Settings</h2>
            <div class="setting-group">
                <label for="test-duration">Select Test Duration:</label>
                <select id="test-duration">
                    <option value="1">1 Minute</option>
                    <option value="2">2 Minutes</option>
                    <option value="3">3 Minutes</option>
                    <option value="5" selected>5 Minutes</option>
                    <option value="10">10 Minutes</option>
                    <option value="15">15 Minutes</option>
                    <option value="20">20 Minutes</option>
                    <option value="30">30 Minutes</option>
                </select>
            </div>

            <div class="setting-group">
                <label for="target-wpm">Your Target WPM (Optional):</label>
                <input type="number" id="target-wpm" min="10" max="200" placeholder="e.g., 40">
            </div>

            <div class="setting-group">
                <label for="target-accuracy">Your Target Accuracy % (Optional):</label>
                <input type="number" id="target-accuracy" min="50" max="100" placeholder="e.g., 95">
            </div>

            <div class="setting-group">
                <label for="story-type">Story Type:</label>
                <select id="story-type">
                    <option value="random-words" selected>Random Words (Default)</option>
                    <option value="ai-story">AI Generated Story (Requires Backend)</option>
                    <option value="user-custom">User Custom Story</option>
                </select>
            </div>

            <div id="custom-story-area">
                <label for="custom-story-textarea">Paste your story here:</label>
                <textarea id="custom-story-textarea" placeholder="Paste the text you want to type here..."></textarea>
                <div class="custom-story-controls">
                    <button class="button secondary" id="add-story-link-button">Add Story from Reedsy</button>
                </div>
            </div>

            <div class="button-group">
                <button class="button primary" id="save-settings-button">Start Test</button>
                <button class="button secondary" id="skip-settings-button">Skip & Start Default</button>
            </div>
        </div>
    </div>

    <div class="container content-hidden" id="main-content">
        <h1>Advanced English Typing Test</h1>

        <div class="stats top-stats">
            <div class="stat-item">
                <h3>Speed (WPM)</h3>
                <p id="wpm">0</p>
            </div>
            <div class="stat-item">
                <h3>Accuracy (%)</h3>
                <p id="accuracy">0</p>
            </div>
            <div class="stat-item">
                <h3>Errors</h3>
                <p id="errors">0</p>
            </div>
            <div class="stat-item cpm-item">
                <h3>CPM</h3>
                <p id="cpm">0</p>
            </div>
            <div class="stat-item timer-item">
                <h3>Time Left</h3>
                <p id="countdown">00:00</p>
            </div>
        </div>

        <div class="test-area" id="test-area">
            </div>

        <input type="text" id="typing-input" placeholder="Start typing here...">

        <div class="controls">
            <button class="button primary" id="restart-button">Restart Test</button>
            <button class="button secondary" id="settings-button">Settings</button>
        </div>

        <div class="result-modal" id="result-modal">
            <div class="modal-content">
                <h2>Test Results</h2>
                <div class="stats">
                    <div class="stat-item">
                        <h3>Final Speed (WPM)</h3>
                        <p id="final-wpm" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final Accuracy (%)</h3>
                        <p id="final-accuracy" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Total Errors</h3>
                        <p id="final-errors" class="result-value-red">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Raw WPM</h3>
                        <p id="raw-wpm" class="result-value-purple">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final CPM</h3>
                        <p id="final-cpm" class="result-value-orange">0</p>
                    </div>
                    <div class="stat-item target-status" id="wpm-target-status">
                        <h3>WPM Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                    <div class="stat-item target-status" id="accuracy-target-status">
                        <h3>Accuracy Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                </div>
                <button class="button primary" id="modal-restart-button">Restart Test</button>
                <button class="button secondary" id="modal-settings-button">New Test with Settings</button>
            </div>
        </div>
    </div>

    <script>
        // Function to fetch AI-generated stories (simulated for now)
        async function fetchAIGeneratedStory(lengthCategory = 'medium') {
            // In a real application, this would be an API call to your backend
            // For GitHub Pages, you'd need to deploy a backend (e.g., on Render)
            // and replace this with your actual API endpoint.
            // Example: const response = await fetch('YOUR_BACKEND_API_ENDPOINT/generate-story', {
            //    method: 'POST',
            //    headers: { 'Content-Type': 'application/json' },
            //    body: JSON.stringify({ length: lengthCategory })
            // });
            // const data = await response.json();
            // return data.story;

            // --- MOCK AI GENERATION FOR FRONTEND ONLY ---
            // Since we can't run real AI on GitHub Pages without a backend,
            // we'll simulate it by picking a longer random passage from a predefined list.
            const longStories = [
                "In a quaint village nestled between rolling hills and a winding river, lived a curious young inventor named Elara. Her days were spent tinkering with gears, wires, and strange contraptions in her small, cluttered workshop. The villagers often chuckled at her eccentricities, but they also secretly admired her unwavering dedication. One day, a fierce storm swept through the valley, knocking out power and isolating the village. Elara, with a twinkle in her eye, knew this was her moment to shine. She unveiled her latest invention: a device that could harness the raw energy of the storm itself, providing light and warmth to every home. With a flick of a switch, the village square lit up, casting a warm glow that banished the darkness and brought hope to the hearts of the people. From that day forward, Elara was no longer just a curious inventor; she was their beacon of light.",
                "The ancient library was a labyrinth of forgotten knowledge, its shelves stretching towards a vaulted ceiling, filled with books bound in leather and imbued with the scent of aged paper. Maya, an aspiring historian, had always dreamed of uncovering its secrets. Legend spoke of a hidden chamber, accessible only to those who could decipher the riddles woven into the very architecture of the building. Armed with a dusty map and her keen intellect, Maya spent weeks tracing symbols and solving puzzles, her fingers trailing over forgotten inscriptions. Finally, a section of the wall receded with a soft click, revealing a spiral staircase descending into darkness. Below, she found not gold or jewels, but a single, illuminated tome, its pages filled with the true history of their world, a history far grander and more intricate than any she had ever read.",
                "The city of Neo-Veridia hummed with the silent thrum of hover-cars and the glow of holographic advertisements. Humans and advanced AI lived side-by-side, their lives intertwined in a complex dance of technology and tradition. Kael, a data archivist, spent his days sifting through digital remnants of the past, seeking patterns and anomalies. One evening, he stumbled upon a peculiar data stream â€“ an encrypted message from an unknown source, speaking of a long-lost natural world, untouched by urbanization. Driven by an insatiable curiosity, Kael followed the digital breadcrumbs, leading him to an ancient, forgotten port where a single, dilapidated spacecraft awaited. It was a journey into the unknown, a quest to find the whispered legends of green forests, blue oceans, and the untamed beauty of a world before concrete and chrome."
            ];
            const shortStories = [
                "The cat slept soundly by the fire, purring softly. A gentle rain fell outside, tapping on the windowpane. Soon, morning light would fill the room, waking the house. Life was simple and good.",
                "A tiny seed lay buried deep in the earth, dreaming of the sun. Slowly, it pushed a root down and a sprout up. Green leaves unfurled, reaching for the sky. It grew into a strong oak tree.",
                "The old lighthouse stood tall against the stormy sea, its beam cutting through the fog. For generations, it guided ships safely to shore. A silent guardian, it watched over the waves.",
                "She picked up her brush and dabbed paint onto the canvas. Colors swirled, forming landscapes and dreams. Each stroke brought a new world to life, born from her imagination and skill."
            ];
            const randomWordList = [
                "the", "quick", "brown", "fox", "jumps", "over", "lazy", "dog", "typing", "practice", "keyboard", "speed", "accuracy", "challenge", "learn", "javascript", "html", "css", "web", "development", "program", "computer", "science", "internet", "browser", "editor", "function", "variable", "element", "document", "style", "console", "terminal", "algorithm", "data", "structure", "network", "server", "client", "request", "response", "protocol", "security", "encryption", "database", "query", "framework", "library", "component", "module", "package", "version", "control", "repository", "commit", "branch", "merge", "pull", "push", "remote", "local", "online", "offline", "connect", "disconnect", "upload", "download", "install", "update", "delete", "create", "read", "write", "execute", "debug", "test", "deploy", "monitor", "optimize", "scale", "automate", "build", "run", "stop", "start", "restart", "configure", "setup", "manage", "organize", "design", "develop", "implement", "maintain", "support", "troubleshoot", "resolve", "solution", "problem", "issue", "error", "warning", "success", "failure", "progress", "status", "report", "log", "history", "analytics", "metric", "performance", "resource", "memory", "cpu", "disk", "bandwidth", "latency", "throughput", "reliability", "availability", "scalability", "maintainability", "usability", "flexibility", "extensibility", "portability", "security", "integrity", "confidentiality", "authentication", "authorization", "audit", "compliance", "regulation", "standard", "guideline", "best", "practice", "pattern", "design", "architecture", "model", "diagram", "flowchart", "pseudocode", "documentation", "comment", "refactor", "optimize", "debug", "test", "deploy", "monitor", "alert", "log", "trace", "profile", "benchmark", "analysis", "report", "summary", "detail", "overview", "context", "scope", "requirement", "specification", "feature", "bug", "fix", "patch", "release", "version", "update", "upgrade", "downgrade", "install", "uninstall", "setup", "configure", "customize", "personalize", "settings", "options", "preferences", "profile", "account", "user", "admin", "guest", "role", "permission", "access", "control", "security", "privacy", "data", "information", "knowledge", "wisdom", "intelligence", "learning", "education", "training", "course", "lesson", "tutorial", "guide", "manual", "book", "article", "blog", "forum", "community", "support", "help", "faq", "troubleshoot", "debug", "solve", "resolve", "fix", "repair", "restore", "backup", "recover", "archive", "compress", "decompress", "encrypt", "decrypt", "hash", "checksum", "validate", "verify", "authenticate", "authorize", "grant", "revoke", "deny", "allow", "enable", "disable", "toggle", "switch", "activate", "deactivate", "start", "stop", "pause", "resume", "cancel", "abort", "retry", "redo", "undo", "save", "load", "open", "close", "new", "edit", "delete", "copy", "cut", "paste", "select", "all", "clear", "reset", "submit", "send", "receive", "download", "upload", "import", "export", "share", "print", "preview", "zoom", "in", "out", "fit", "width", "height", "actual", "size", "fullscreen", "exit", "search", "filter", "sort", "group", "categorize", "tag", "label", "mark", "favorite", "bookmark", "pin", "hide", "show", "collapse", "expand", "move", "rename", "duplicate", "clone", "merge", "split", "join", "combine", "separate", "extract", "insert", "remove", "replace", "find", "replace", "goto", "line", "column", "character", "word", "sentence", "paragraph", "document", "file", "folder", "directory", "path", "url", "uri", "urn", "protocol", "host", "port", "query", "fragment", "scheme", "authority", "userinfo", "hostname", "pathname", "search", "hash", "origin", "protocol", "domain", "subdomain", "top-level", "second-level", "country-code", "generic", "reserved", "public", "private", "local", "global", "internal", "external", "remote", "cloud", "on-premise", "hybrid", "distributed", "centralized", "decentralized", "peer-to-peer", "client-server", "front-end", "back-end", "full-stack", "desktop", "mobile", "web", "native", "cross-platform", "hybrid", "responsive", "adaptive", "fluid", "fixed", "grid", "flexbox", "bootstrap", "material", "design", "ui", "ux", "interface", "experience", "interaction", "usability", "accessibility", "performance", "security", "scalability", "reliability", "availability", "maintainability", "testability", "extensibility", "flexibility", "portability", "reusability", "modularity", "simplicity", "consistency", "efficiency", "robustness", "error-handling", "logging", "monitoring", "debugging", "testing", "deployment", "automation", "scripting", "programming", "coding", "software", "hardware", "firmware", "middleware", "operating", "system", "kernel", "shell", "command", "line", "interface", "graphical", "user", "interface", "api", "sdk", "library", "framework", "tool", "utility", "application", "program", "service", "daemon", "process", "thread", "concurrency", "parallelism", "synchronization", "asynchronous", "callback", "promise", "async", "await", "event", "loop", "queue", "stack", "heap", "tree", "graph", "linked", "list", "array", "object", "map", "set", "iterator", "generator", "decorator", "closure", "higher-order", "function", "pure", "function", "side-effect", "idempotent", "immutable", "mutable", "state", "stateless", "stateful", "component", "props", "state", "lifecycle", "hook", "context", "provider", "consumer", "reducer", "action", "dispatch", "store", "subscribe", "unsubscribe", "middleware", "thunk", "saga", "redux", "mobx", "vuex", "angular", "react", "vue", "jquery", "lodash", "underscore", "moment", "date-fns", "axios", "fetch", "websocket", "socket.io", "graphql", "rest", "api", "json", "xml", "yaml", "csv", "tsv", "markdown", "html", "css", "javascript", "typescript", "python", "java", "csharp", "go", "rust", "php", "ruby", "swift", "kotlin", "scala", "haskell", "clojure", "lisp", "erlang", "elixir", "perl", "bash", "shell", "powershell", "sql", "nosql", "mongodb", "postgresql", "mysql", "sqlite", "redis", "cassandra", "elasticsearch", "kafka", "rabbit", "mq", "aws", "azure", "gcp", "docker", "kubernetes", "git", "github", "gitlab", "bitbucket", "jenkins", "travis", "ci", "circleci", "github", "actions", "azure", "devops", "jira", "trello", "asana", "slack", "discord", "zoom", "google", "meet", "microsoft", "teams", "outlook", "gmail", "calendar", "drive", "docs", "sheets", "slides", "forms", "maps", "youtube", "twitter", "facebook", "instagram", "linkedin", "snapchat", "tiktok", "reddit", "pinterest", "whatsapp", "telegram", "signal", "viber", "wechat", "line", "skype", "facetime", "imessage", "sms", "email", "phone", "call", "video", "audio", "text", "message", "chat", "group", "channel", "thread", "notification", "alert", "badge", "icon", "button", "link", "input", "text", "area", "checkbox", "radio", "select", "option", "dropdown", "slider", "range", "progress", "bar", "spinner", "loader", "tooltip", "popover", "modal", "dialog", "accordion", "tabs", "carousel", "pagination", "breadcrumb", "navbar", "sidebar", "footer", "header", "main", "section", "article", "aside", "figure", "figcaption", "details", "summary", "dialog", "menu", "item", "list", "unordered", "ordered", "definition", "table", "row", "column", "cell", "caption", "thead", "tbody", "tfoot", "form", "fieldset", "legend", "label", "input", "textarea", "button", "select", "option", "datalist", "output", "meter", "progress", "img", "picture", "source", "svg", "canvas", "audio", "video", "track", "embed", "iframe", "object", "param", "map", "area", "link", "meta", "style", "script", "noscript", "template", "slot", "abbr", "address", "b", "bdi", "bdo", "blockquote", "cite", "code", "del", "dfn", "em", "i", "ins", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "acronym", "applet", "basefont", "big", "center", "dir", "font", "frame", "frameset", "noframes", "strike", "tt"
            ];
            // If random-words is selected, we combine words to form a longer story for variety
            if (lengthCategory === 'random-words') {
                let generatedText = "";
                // Increase base word count to ensure enough text for longer durations
                const baseWordCount = 300; 
                const targetWordCount = baseWordCount * (testDurationSelect.value / 5); 
                for (let i = 0; i < targetWordCount; i++) {
                    generatedText += randomWordList[Math.floor(Math.random() * randomWordList.length)] + " ";
                }
                return generatedText.trim();
            } else if (lengthCategory === 'short') {
                return shortStories[Math.floor(Math.random() * shortStories.length)];
            } else if (lengthCategory === 'long') {
                return longStories[Math.floor(Math.random() * longStories.length)];
            } else { // 'medium' or default AI story fallback
                return "The sun dipped below the horizon, painting the sky in hues of orange and purple. A lone bird soared across the fading light, its wings catching the last rays. Below, the city lights began to twinkle, promising a night of bustling activity. A gentle breeze carried the scent of blooming jasmine through the open window. It was a perfect evening to reflect on the day's events and anticipate the quiet hours ahead. The world felt at peace, a symphony of subtle changes unfolding as darkness embraced the landscape, bringing with it the promise of a new dawn and fresh opportunities. Every moment held a quiet beauty, a fleeting perfection that made the heart sing with gratitude for its simple existence.";
            }
        }
        // --- END MOCK AI GENERATION ---

        // DOM Elements
        const mainContent = document.getElementById('main-content');
        const testArea = document.getElementById('test-area');
        const typingInput = document.getElementById('typing-input');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const errorsDisplay = document.getElementById('errors');
        const cpmDisplay = document.getElementById('cpm'); // New CPM display
        const countdownDisplay = document.getElementById('countdown');
        const restartButton = document.getElementById('restart-button');
        const settingsButton = document.getElementById('settings-button');
        const resultModal = document.getElementById('result-modal');
        const finalWpmDisplay = document.getElementById('final-wpm');
        const finalAccuracyDisplay = document.getElementById('final-accuracy');
        const finalErrorsDisplay = document.getElementById('final-errors');
        const rawWpmDisplay = document.getElementById('raw-wpm');
        const finalCpmDisplay = document.getElementById('final-cpm'); // New Final CPM display
        const modalRestartButton = document.getElementById('modal-restart-button');
        const modalSettingsButton = document.getElementById('modal-settings-button');

        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settings-overlay');
        const testDurationSelect = document.getElementById('test-duration');
        const targetWpmInput = document.getElementById('target-wpm');
        const targetAccuracyInput = document.getElementById('target-accuracy');
        const storyTypeSelect = document.getElementById('story-type');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const skipSettingsButton = document.getElementById('skip-settings-button');
        const wpmTargetStatus = document.getElementById('wpm-target-status');
        const accuracyTargetStatus = document.getElementById('accuracy-target-status');

        // New Custom Story Elements
        const customStoryArea = document.getElementById('custom-story-area');
        const customStoryTextarea = document.getElementById('custom-story-textarea');
        const addStoryLinkButton = document.getElementById('add-story-link-button');

        // Global Variables
        let testWords = [];
        let wordIndex = 0;
        let charIndex = 0; // Not strictly used for char tracking, but good practice
        let startTime;
        let timerInterval;
        let defaultTestDuration = 5 * 60; // Default 5 minutes in seconds
        let timeLeft = defaultTestDuration;
        let correctChars = 0;
        let incorrectChars = 0;
        let typedCharsOverall = 0; // Total characters typed including errors and backspaces

        let userTargetWPM = null;
        let userTargetAccuracy = null;
        let currentStoryType = 'random-words'; // Default story type
        let customStoryText = ''; // Stores user's custom story

        let testContentArray = []; // Stores words and newline indicators

        // Utility to format time
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        async function generateAndRenderTestWords() {
            testWords = []; // Reset words for typing logic
            testContentArray = []; // Reset full content array

            let textToType = "";

            if (currentStoryType === 'ai-story') {
                let lengthCategory = 'medium'; // Default for AI story
                const durationMinutes = parseInt(testDurationSelect.value);
                if (durationMinutes <= 2) {
                    lengthCategory = 'short';
                } else if (durationMinutes >= 10) {
                    lengthCategory = 'long';
                }
                textToType = await fetchAIGeneratedStory(lengthCategory);
            } else if (currentStoryType === 'user-custom') {
                textToType = customStoryText.trim();
                if (textToType === "") {
                    alert("Please paste your custom story in the text area or select another story type.");
                    settingsOverlay.classList.add('show');
                    mainContent.classList.add('content-hidden');
                    return; // Stop function execution
                }
            } else { // random-words
                textToType = await fetchAIGeneratedStory('random-words');
            }

            testArea.innerHTML = ''; // Clear previous content

            // Process text to handle paragraphs and line breaks
            const paragraphs = textToType.split(/\r?\n/); // Split by newline characters

            paragraphs.forEach((paragraphText, paraIdx) => {
                const paragraphDiv = document.createElement('div');
                paragraphDiv.classList.add('paragraph');

                const wordsInParagraph = paragraphText.split(/\s+/).filter(word => word.length > 0);

                wordsInParagraph.forEach((word, wordIdxInPara) => {
                    // Add word to testContentArray
                    testContentArray.push(word);

                    const wordSpan = document.createElement('span');
                    wordSpan.classList.add('word');
                    word.split('').forEach(char => {
                        const charSpan = document.createElement('span');
                        charSpan.textContent = char;
                        charSpan.classList.add('untyped');
                        wordSpan.appendChild(charSpan);
                    });

                    // Add a space span after each word (except the last one in the paragraph)
                    if (wordIdxInPara < wordsInParagraph.length - 1) {
                        const spaceSpan = document.createElement('span');
                        spaceSpan.textContent = ' ';
                        spaceSpan.classList.add('char-space');
                        spaceSpan.classList.add('untyped');
                        wordSpan.appendChild(spaceSpan);
                    }
                    paragraphDiv.appendChild(wordSpan);
                });

                // Add a newline indicator if it's not the very last paragraph and there's actually content
                if (paraIdx < paragraphs.length -1 && paragraphText.length > 0) {
                     // Only add newline indicator if there's actual content on this line
                    testContentArray.push('\n'); // Special indicator for newline
                }
                
                testArea.appendChild(paragraphDiv);
            });

            // Flatten testContentArray into testWords for simpler word-by-word tracking
            // This ensures we can iterate through `testWords` linearly for `wordIndex`
            // and `testContentArray` represents the display structure.
            // This can be tricky. Let's make `testWords` represent the actual expected characters for typing.
            // For custom story with newlines, `testWords` will now contain actual words and '\n' markers.

            // Re-processing testWords to include newline characters for accurate indexing
            testWords = [];
            paragraphs.forEach((paragraphText, paraIdx) => {
                const wordsInParagraph = paragraphText.split(/\s+/).filter(word => word.length > 0);
                testWords = testWords.concat(wordsInParagraph);
                if (paraIdx < paragraphs.length -1 && paragraphText.length > 0) {
                    testWords.push('\n'); // Add newline character as a distinct "word"
                }
            });

            highlightCurrentWord();
            adjustTestAreaScroll();
        }

        // Helper to get the actual DOM word span based on wordIndex
        function getDomWordSpan(idx) {
            let currentDomWordIndex = -1;
            for (let i = 0; i < testArea.children.length; i++) {
                const paragraphDiv = testArea.children[i];
                if (paragraphDiv.classList.contains('paragraph')) {
                    for (let j = 0; j < paragraphDiv.children.length; j++) {
                        const wordSpan = paragraphDiv.children[j];
                        if (wordSpan.classList.contains('word')) {
                            currentDomWordIndex++;
                            if (currentDomWordIndex === idx) {
                                return wordSpan;
                            }
                        }
                    }
                    // If a newline was present, it also counts as a "word" in testWords
                    // We need to account for it in the DOM word index too
                    // This is tricky. A more direct mapping is needed.
                }
            }
            return null;
        }

        function highlightCurrentWord() {
            // Remove highlighting from all words first
            testArea.querySelectorAll('.word').forEach(span => {
                span.classList.remove('current-word');
            });

            let currentDomWordSpan = null;
            let currentTheoreticalWordIndex = 0;

            // Iterate through paragraphs and words to find the correct DOM span
            for (let i = 0; i < testArea.children.length; i++) {
                const paragraphDiv = testArea.children[i];
                if (paragraphDiv.classList.contains('paragraph')) {
                    for (let j = 0; j < paragraphDiv.children.length; j++) {
                        const wordSpan = paragraphDiv.children[j];
                        if (wordSpan.classList.contains('word')) {
                            if (currentTheoreticalWordIndex === wordIndex) {
                                currentDomWordSpan = wordSpan;
                                break; // Found it
                            }
                            currentTheoreticalWordIndex++;
                        }
                    }
                }
                // If the current testWords element is a newline, increment theoretical index
                if (testWords[currentTheoreticalWordIndex] === '\n') {
                    // This means we are at the end of a line, expecting an Enter
                    // The next word in testWords is actually on a new line in the DOM.
                    // We don't have a direct DOM element for '\n' itself, so this adjustment
                    // helps `currentTheoreticalWordIndex` stay in sync with `wordIndex`.
                    // If we just typed a word and are moving to a '\n', we increment theoretical.
                    if (currentTheoreticalWordIndex === wordIndex) {
                        break; // Found the newline "word" in testWords, no DOM element for it.
                    }
                    currentTheoreticalWordIndex++;
                }
                if (currentDomWordSpan) break; // Break outer loop if found
            }

            if (currentDomWordSpan) {
                currentDomWordSpan.classList.add('current-word');
            }
            adjustTestAreaScroll();
        }


        // Function to automatically scroll the test area
        function adjustTestAreaScroll() {
            // Find the active paragraph's word
            let targetWordSpan = null;
            let currentTheoreticalWordIndex = 0;
            for (let i = 0; i < testArea.children.length; i++) {
                const paragraphDiv = testArea.children[i];
                if (paragraphDiv.classList.contains('paragraph')) {
                    for (let j = 0; j < paragraphDiv.children.length; j++) {
                        const wordSpan = paragraphDiv.children[j];
                        if (wordSpan.classList.contains('word')) {
                            if (currentTheoreticalWordIndex === wordIndex) {
                                targetWordSpan = wordSpan;
                                break;
                            }
                            currentTheoreticalWordIndex++;
                        }
                    }
                }
                // If the current testWords element is a newline, increment theoretical index
                if (testWords[currentTheoreticalWordIndex] === '\n') {
                    if (currentTheoreticalWordIndex === wordIndex) {
                        // If the current "word" is a newline, we need to scroll to the beginning of the NEXT paragraph
                        // to ensure it's visible. Or simply adjust based on the current word's previous position.
                        // For scrolling, focusing on the last word of the previous line (if applicable) or the start of the next is key.
                        // Let's make sure the next word is visible.
                        if (currentTheoreticalWordIndex + 1 < testWords.length) {
                             // Try to find the first word of the next paragraph
                            let nextDomWordIndex = currentTheoreticalWordIndex + 1;
                            let foundNextWord = false;
                            for (let pIdx = i; pIdx < testArea.children.length; pIdx++) {
                                const nextParagraphDiv = testArea.children[pIdx];
                                if (nextParagraphDiv.classList.contains('paragraph')) {
                                    if (nextParagraphDiv.children.length > 0) {
                                        targetWordSpan = nextParagraphDiv.children[0]; // First word of next paragraph
                                        foundNextWord = true;
                                        break;
                                    }
                                }
                            }
                            if (foundNextWord) break;
                        } else {
                            // Last element was a newline, nothing more to type
                            break;
                        }
                    }
                    currentTheoreticalWordIndex++;
                }
                if (targetWordSpan) break;
            }


            if (!targetWordSpan) return;

            const testAreaRect = testArea.getBoundingClientRect();
            const wordRect = targetWordSpan.getBoundingClientRect();

            // Calculate vertical scroll
            // Check if the word is below the visible area
            if (wordRect.bottom > testAreaRect.bottom) {
                testArea.scrollTop += (wordRect.bottom - testAreaRect.bottom) + 10; // Scroll down by diff + a little buffer
            }
            // Check if the word is above the visible area (e.g., after a backspace or reset, or re-render)
            else if (wordRect.top < testAreaRect.top) {
                testArea.scrollTop -= (testAreaRect.top - wordRect.top) + 10; // Scroll up by diff + a little buffer
            }
        }


        function updateStats() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            if (timeElapsed === 0) {
                cpmDisplay.textContent = 0;
                return; // Avoid division by zero at start
            }

            const minutesElapsed = timeElapsed / 60;

            // WPM calculation: (Correct Words / Time in Minutes)
            // A "word" is often defined as 5 characters including spaces.
            // For more robust WPM, we can use (Correct Chars / 5)
            const currentWPM = Math.round((correctChars / 5) / minutesElapsed);
            wpmDisplay.textContent = isNaN(currentWPM) ? 0 : currentWPM;

            // CPM calculation: Total Correct Characters / (Time in Minutes)
            const currentCPM = Math.round(correctChars / minutesElapsed);
            cpmDisplay.textContent = isNaN(currentCPM) ? 0 : currentCPM;

            const currentAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            accuracyDisplay.textContent = isNaN(currentAccuracy) ? 0 : currentAccuracy;
            errorsDisplay.textContent = incorrectChars;
        }


        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = formatTime(timeLeft);
                updateStats();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endTest();
                }
            }, 1000);
        }

        function endTest() {
            typingInput.disabled = true;
            typingInput.value = '';
            clearInterval(timerInterval);
            updateStats(); // Final update

            const timeElapsed = (defaultTestDuration - timeLeft);
            const finalMinutesElapsed = timeElapsed / 60;

            // Handle potential division by zero if test ended immediately for some reason
            const finalWPM = finalMinutesElapsed > 0 ? Math.round((correctChars / 5) / finalMinutesElapsed) : 0;
            const finalAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            const finalRawWPM = finalMinutesElapsed > 0 ? Math.round((typedCharsOverall / 5) / finalMinutesElapsed) : 0;
            const finalCPM = finalMinutesElapsed > 0 ? Math.round(correctChars / finalMinutesElapsed) : 0;


            finalWpmDisplay.textContent = isNaN(finalWPM) ? 0 : finalWPM;
            finalAccuracyDisplay.textContent = isNaN(finalAccuracy) ? 0 : finalAccuracy;
            finalErrorsDisplay.textContent = incorrectChars;
            rawWpmDisplay.textContent = isNaN(finalRawWPM) ? 0 : finalRawWPM;
            finalCpmDisplay.textContent = isNaN(finalCPM) ? 0 : finalCPM; // Set Final CPM

            // Add color to final results
            finalWpmDisplay.className = 'result-value-green';
            finalAccuracyDisplay.className = 'result-value-green';
            finalErrorsDisplay.className = 'result-value-red'; // Errors are bad, so red
            rawWpmDisplay.className = 'result-value-purple';
            finalCpmDisplay.className = 'result-value-orange';


            // Check and update target status
            if (userTargetWPM !== null && !isNaN(userTargetWPM)) {
                if (finalWPM >= userTargetWPM) {
                    wpmTargetStatus.querySelector('p').textContent = `Met (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    wpmTargetStatus.querySelector('p').textContent = `Missed (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                wpmTargetStatus.querySelector('p').textContent = 'N/A';
                wpmTargetStatus.querySelector('p').className = 'status-neutral';
            }

            if (userTargetAccuracy !== null && !isNaN(userTargetAccuracy)) {
                if (finalAccuracy >= userTargetAccuracy) {
                    accuracyTargetStatus.querySelector('p').textContent = `Met (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    accuracyTargetStatus.querySelector('p').textContent = `Missed (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                accuracyTargetStatus.querySelector('p').textContent = 'N/A';
                accuracyTargetStatus.querySelector('p').className = 'status-neutral';
            }

            resultModal.classList.add('show');
            // Allow restart and settings access after test ends
            restartButton.disabled = false;
            settingsButton.disabled = false;
        }

        async function initializeTest(duration, targetWPM, targetAccuracy, storyType, customText = '') {
            clearInterval(timerInterval);
            defaultTestDuration = duration * 60; // Convert minutes to seconds
            timeLeft = defaultTestDuration;
            countdownDisplay.textContent = formatTime(timeLeft);
            wordIndex = 0;
            charIndex = 0;
            correctChars = 0;
            incorrectChars = 0;
            typedCharsOverall = 0;
            typingInput.value = '';
            typingInput.disabled = false;
            startTime = null; // Reset start time
            
            userTargetWPM = targetWPM ? parseInt(targetWPM) : null;
            userTargetAccuracy = targetAccuracy ? parseInt(targetAccuracy) : null;
            currentStoryType = storyType;
            customStoryText = customText; // Set custom story if provided

            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '0';
            errorsDisplay.textContent = '0';
            cpmDisplay.textContent = '0'; // Reset CPM display

            // Ensure buttons are clickable for a new test or settings
            restartButton.disabled = false; 
            settingsButton.disabled = false;
            
            // Generate words and check if successful (e.g., custom story not empty)
            await generateAndRenderTestWords();
            if (testWords.length === 0 && currentStoryType === 'user-custom') {
                // If custom story was selected but empty, do not proceed with test
                return; 
            }

            typingInput.focus();
            resultModal.classList.remove('show');
            settingsOverlay.classList.remove('show'); // Hide settings overlay
            mainContent.classList.remove('content-hidden'); // Show main content
        }

        // Event Listeners

        // Typing Input Listener
        typingInput.addEventListener('input', (e) => {
            if (!startTime) {
                startTimer(); // Start timer on first input
            }
            
            // Get the current expected word (or newline marker)
            const currentExpectedItem = testWords[wordIndex];
            const typedText = e.target.value;
            
            // Handle newline character separately
            if (currentExpectedItem === '\n') {
                // If the user presses Enter, we consider it correct and move to the next "word"
                if (typedText === '') { // Input is cleared on Enter
                    // This means a previous Enter was processed, and input is now empty.
                    // Do nothing here, wait for next real input.
                } else {
                    // User typed something when expecting an Enter (handled in keydown, or if they paste multiple lines)
                    // This scenario is tricky for 'input' event alone. 
                    // Let's rely on keydown for processing Enter.
                }
                return; // Do not process as a regular word
            }

            const currentWordExpected = currentExpectedItem; // Actual word
            const currentWordSpan = getDomWordSpan(wordIndex); // Get the DOM span for the current word

            if (!currentWordSpan) { // No more words to type or issue finding word
                endTest();
                return;
            }

            const charSpans = Array.from(currentWordSpan.children); 

            // Update char rendering within the current word
            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                const charSpan = charSpans[i];

                if (charSpan) {
                    charSpan.classList.remove('correct', 'incorrect', 'untyped', 'extra');
                    if (typedChar === undefined) {
                        charSpan.classList.add('untyped');
                    } else if (typedChar === charExpected) {
                        charSpan.classList.add('correct');
                    } else {
                        charSpan.classList.add('incorrect');
                    }
                }
            }

            // Handle the space character (if it exists for this word)
            const spaceSpan = charSpans[currentWordExpected.length]; // This should be the space span if it's not the last word
            if (spaceSpan && spaceSpan.classList.contains('char-space')) {
                spaceSpan.classList.remove('correct', 'incorrect', 'untyped');
                if (typedText[currentWordExpected.length] === ' ') {
                    spaceSpan.classList.add('correct');
                } else if (typedText[currentWordExpected.length] !== undefined) {
                    spaceSpan.classList.add('incorrect');
                } else {
                    spaceSpan.classList.add('untyped');
                }
            }


            // Handle extra characters typed (beyond the current word's length AND potential space)
            // First, hide any previously rendered 'extra' chars
            for (let i = currentWordExpected.length + 1; i < charSpans.length; i++) {
                charSpans[i].style.display = 'none'; 
            }
            // Then, render new extra chars
            for (let i = currentWordExpected.length + (spaceSpan ? 1 : 0); i < typedText.length; i++) {
                let extraSpan = charSpans[i];
                if (!extraSpan) { // Create if it doesn't exist
                    extraSpan = document.createElement('span');
                    currentWordSpan.appendChild(extraSpan);
                }
                extraSpan.textContent = typedText[i];
                extraSpan.classList.add('extra');
                extraSpan.style.display = 'inline-block';
            }
            
            // If word is completed (space pressed for word, or exact match for last word without trailing space)
            const isLastWord = wordIndex === testWords.length - 1;
            const typedWordExactMatch = typedText === currentWordExpected && isLastWord;
            const typedWordWithSpace = typedText.endsWith(' ') && typedText.trim() === currentWordExpected;

            if (typedWordWithSpace || typedWordExactMatch) {
                // Determine the correct characters for the current "word" (including space if applicable)
                let tempCorrectChars = 0;
                let tempIncorrectChars = 0;

                for (let i = 0; i < currentWordExpected.length; i++) {
                    if (typedText[i] === currentWordExpected[i]) {
                        tempCorrectChars++;
                    } else {
                        tempIncorrectChars++;
                    }
                }

                // Handle the trailing space for words (not for newlines)
                if (spaceSpan && typedText.length > currentWordExpected.length) {
                    if (typedText[currentWordExpected.length] === ' ') {
                        tempCorrectChars++;
                    } else {
                        tempIncorrectChars++;
                    }
                } else if (spaceSpan && typedText.length === currentWordExpected.length) {
                    // User typed the word correctly but missed the space, count as error
                    tempIncorrectChars++;
                }


                // Account for extra characters typed beyond the expected word (+ space)
                const expectedLength = currentWordExpected.length + (spaceSpan ? 1 : 0);
                if (typedText.length > expectedLength) {
                    tempIncorrectChars += (typedText.length - expectedLength);
                }
                
                correctChars += tempCorrectChars;
                incorrectChars += tempIncorrectChars;
                typedCharsOverall += typedText.length; // Count all characters actually typed for this word

                wordIndex++; // Move to next word
                typingInput.value = ''; // Clear input for next word
                highlightCurrentWord(); // Update highlighting and scroll

                if (wordIndex >= testWords.length) { // End test if all words/newlines are typed
                    endTest();
                    return;
                }
            }
            updateStats(); // Update stats in real-time
        });


        // Handle Enter key for custom stories with newlines
        typingInput.addEventListener('keydown', (e) => {
            if (!startTime) {
                startTimer();
            }

            if (e.key === 'Enter') {
                const currentExpectedItem = testWords[wordIndex];

                // Check if we are actually expecting a newline
                if (currentExpectedItem === '\n') {
                    e.preventDefault(); // Prevent default Enter behavior (new line in input box)

                    // Mark this "newline" as correctly typed
                    correctChars++; // Count newline as one correct char for CPM/WPM calculation
                    typedCharsOverall++; 
                    incorrectChars += typingInput.value.length; // Any text typed before Enter in this 'newline' word is incorrect

                    wordIndex++; // Move past the '\n' "word"
                    typingInput.value = ''; // Clear input
                    highlightCurrentWord(); // Re-highlight (moves to next actual word)

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                    updateStats();
                } else {
                    // If Enter is pressed but we are not expecting a newline, it's an error
                    e.preventDefault(); // Still prevent default, just treat as an error
                    incorrectChars++;
                    typedCharsOverall++;
                    // Optionally: flash a red background or play an error sound
                    // For now, just count the error.
                    updateStats();
                }
            } else if (e.key === 'Backspace') {
                // If Backspace is pressed, re-evaluate characters for visual feedback
                // Note: The 'input' event usually handles state changes due to backspace,
                // but if we need specific visual logic here, it can be added.
                // For simplicity, current 'input' listener handles re-rendering of spans.
            }
        });


        restartButton.addEventListener('click', () => {
            // Show settings overlay on restart
            settingsOverlay.classList.add('show');
            resultModal.classList.remove('show'); // Hide result modal if open
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly on re-opening settings
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        settingsButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        saveSettingsButton.addEventListener('click', async () => {
            const duration = parseInt(testDurationSelect.value);
            const targetWPM = targetWpmInput.value;
            const targetAccuracy = targetAccuracyInput.value;
            const storyType = storyTypeSelect.value;
            let storyContent = '';

            if (storyType === 'user-custom') {
                storyContent = customStoryTextarea.value.trim();
                if (storyContent === "") {
                    alert("Please paste your custom story in the text area.");
                    return; // Prevent test from starting if custom story is empty
                }
            }
            await initializeTest(duration, targetWPM, targetAccuracy, storyType, storyContent);
        });

        skipSettingsButton.addEventListener('click', async () => {
            await initializeTest(5, null, null, 'random-words'); // Default to 5 mins, no targets, random words
        });

        modalRestartButton.addEventListener('click', async () => {
            await initializeTest(defaultTestDuration / 60, userTargetWPM, userTargetAccuracy, currentStoryType, customStoryText); // Use current settings for restart
        });

        modalSettingsButton.addEventListener('click', () => {
            resultModal.classList.remove('show');
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            // Ensure custom story area is hidden/shown correctly
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; // Show previously typed custom text
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for Story Type dropdown to show/hide custom story area
        storyTypeSelect.addEventListener('change', () => {
            if (storyTypeSelect.value === 'user-custom') {
                customStoryArea.style.display = 'block';
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for "Add Story from Reedsy" button
        addStoryLinkButton.addEventListener('click', () => {
            window.open('https://blog.reedsy.com/short-stories/', '_blank');
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            settingsOverlay.classList.add('show');
            // Hide main content initially
            mainContent.classList.add('content-hidden');
            countdownDisplay.textContent = formatTime(defaultTestDuration); // Show initial default time
            // Ensure custom story area is hidden initially
            customStoryArea.style.display = 'none';
        });

    </script>
</body>
</html>
