<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced English Typing Test (Single File)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght@400;700&family=Source+Code+Pro:wght@400;700&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Font Imports */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #e3f2fd; /* Light Blue background */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align at the top */
            min-height: 100vh;
            padding: 20px;
            background: linear-gradient(to right, #e3f2fd, #fce4ec); /* Light Blue to Light Pink Gradient */
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15); /* More prominent shadow */
            width: 100%;
            max-width: 900px;
            animation: fadeIn 0.8s ease-out;
            border: 1px solid #bbdefb; /* Light blue border */
            position: relative; /* For z-index to work with settings overlay */
            z-index: 1; /* Ensure container is above other elements when settings are hidden */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            text-align: center;
            color: #e91e63; /* Pink primary color */
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5em; /* Larger title */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }

        /* Live Stats Area (moved to top) */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px; /* Space below stats */
            flex-wrap: wrap;
            gap: 15px;
            background-color: #fce4ec; /* Light pink background */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }

        .stat-item {
            background-color: #fff;
            padding: 12px 18px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            text-align: center;
            min-width: 120px;
            flex: 1;
            border: 1px solid #f8bbd0; /* Slightly darker pink border */
        }

        .stat-item h3 {
            color: #6a1b9a; /* Deep purple for sub-headers */
            font-size: 1em;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .stat-item p {
            font-size: 1.8em; /* Slightly smaller for compactness */
            font-weight: bold;
            color: #e91e63; /* Pink for values */
            font-family: 'Montserrat', sans-serif;
        }

        .timer-item p {
            color: #2196f3; /* Blue for timer */
        }

        /* Test Area */
        .test-area {
            margin-bottom: 20px; /* Reduced margin */
            padding: 20px;
            background-color: #f1f8e9; /* Very light green for contrast */
            border-radius: 10px;
            border: 1px solid #dcedc8;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            min-height: 120px; /* Smaller height */
            max-height: 120px; /* Fixed height for 3 lines */
            overflow: hidden; /* Hide overflow */
            position: relative;
            line-height: 1.8; /* More spacing for readability */
            font-size: 1.2em; /* Slightly smaller font for more words per line */
            font-family: 'Open Sans', sans-serif; /* Changed to Open Sans for better readability */
            color: #444;
        }

        .word {
            display: inline-block;
            margin-right: 5px;
            padding: 1px 0;
        }

        .current-word {
            background-color: #fff9c4; /* Light yellow for current word */
            border-radius: 4px;
            padding: 1px 5px;
            box-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
        }

        .correct {
            color: #388e3c; /* Dark green for correct */
        }

        .incorrect {
            color: #d32f2f; /* Dark red for incorrect */
            text-decoration: underline wavy #d32f2f 2px;
        }

        .extra {
            color: #7b7b7b;
            background-color: #ffebee; /* Very light red background for extra */
            border-radius: 3px;
            padding: 0 2px;
        }

        .untyped {
            color: #7b7b7b;
        }

        /* Input Area */
        #typing-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.5em;
            border: 2px solid #ccc;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Source Code Pro', monospace; /* Kept monospace for input */
            background-color: #fcfcfc;
            margin-bottom: 20px; /* Space below input */
        }

        #typing-input:focus {
            border-color: #2196f3; /* Blue on focus */
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
        }

        /* Controls */
        .controls {
            text-align: center;
            margin-top: 20px; /* Reduced margin */
        }

        .button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px; /* Slightly more rounded buttons */
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            margin: 0 10px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
        }

        .button.primary {
            background-color: #e91e63; /* Pink primary */
            color: white;
            box-shadow: 0 4px 8px rgba(233, 30, 99, 0.2);
        }

        .button.primary:hover {
            background-color: #d81b60; /* Darker pink on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(233, 30, 99, 0.3);
        }

        .button.secondary {
            background-color: #2196f3; /* Blue secondary */
            color: white;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.2);
        }

        .button.secondary:hover {
            background-color: #1976d2; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(33, 150, 243, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Result Modal */
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .result-modal.show {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            max-width: 600px; /* Wider modal */
            width: 90%;
            border: 1px solid #bbdefb;
        }

        .result-modal.show .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            color: #e91e63;
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2em;
        }

        .modal-content .stats {
            flex-wrap: wrap; /* Ensure wrapping in modal too */
            justify-content: center;
            margin-bottom: 20px;
        }

        .modal-content .stat-item {
            margin-bottom: 15px;
            background-color: #e3f2fd; /* Light blue in modal stats */
            border: 1px solid #90caf9;
        }

        .modal-content .button {
            margin-top: 25px;
            margin: 10px; /* Space between modal buttons */
        }

        /* Target Status in Modal */
        .stat-item.target-status p {
            font-size: 1.5em; /* Smaller font for target status */
        }
        .status-neutral { color: #607d8b; } /* Grey */
        .status-met { color: #388e3c; } /* Green */
        .status-not-met { color: #d32f2f; } /* Red */

        /* Settings Overlay (Full-screen) */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker, more opaque background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher z-index than container and result modal */
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.4s ease;
        }

        .settings-overlay.show {
            visibility: visible;
            opacity: 1;
        }

        .settings-overlay .settings-content {
            background-color: #f0f4c3; /* Light yellow-green for settings */
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            border: 1px solid #cddc39;
            transform: scale(0.9);
            transition: transform 0.4s ease;
        }

        .settings-overlay.show .settings-content {
            transform: scale(1);
        }

        .settings-overlay h2 {
            color: #4CAF50; /* Green for settings header */
            margin-bottom: 30px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2em;
        }

        .setting-group {
            margin-bottom: 25px; /* More space between groups */
            text-align: left;
        }

        .setting-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px; /* More space below label */
            color: #388e3c; /* Darker green for setting labels */
            font-size: 1.15em;
        }

        .setting-group select,
        .setting-group input[type="number"] {
            width: 100%;
            padding: 12px; /* Larger padding for inputs */
            border: 1px solid #aed581; /* Greenish border */
            border-radius: 8px;
            font-size: 1.1em;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Roboto', sans-serif;
        }

        .setting-group select:focus,
        .setting-group input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        .settings-overlay .button-group {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        /* Initial hidden state for the main content */
        .content-hidden {
            visibility: hidden;
            opacity: 0;
            height: 0;
            overflow: hidden;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            .stats {
                gap: 10px;
            }

            .stat-item {
                min-width: 100px;
                padding: 10px 12px;
            }

            .stat-item p {
                font-size: 1.5em;
            }

            .test-area {
                font-size: 1.1em;
                padding: 15px;
                min-height: 100px;
                max-height: 100px;
            }

            #typing-input {
                font-size: 1.2em;
                padding: 10px 15px;
            }

            .button {
                padding: 10px 20px;
                font-size: 1em;
                margin: 5px;
            }

            .modal-content {
                padding: 25px;
            }

            .modal-content h2 {
                font-size: 1.8em;
            }

            .settings-overlay .settings-content {
                padding: 25px;
            }
            .settings-overlay h2 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            .setting-group {
                margin-bottom: 20px;
            }
            .settings-overlay .button-group {
                flex-direction: column;
                gap: 15px;
            }
            .settings-overlay .button {
                width: 80%; /* Make buttons wider on small screens */
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <div class="settings-overlay" id="settings-overlay">
        <div class="settings-content">
            <h2>Typing Test Settings</h2>
            <div class="setting-group">
                <label for="test-duration">Select Test Duration:</label>
                <select id="test-duration">
                    <option value="1">1 Minute</option>
                    <option value="2">2 Minutes</option>
                    <option value="3">3 Minutes</option>
                    <option value="5" selected>5 Minutes</option>
                    <option value="10">10 Minutes</option>
                    <option value="15">15 Minutes</option>
                    <option value="20">20 Minutes</option>
                    <option value="30">30 Minutes</option>
                </select>
            </div>

            <div class="setting-group">
                <label for="target-wpm">Your Target WPM (Optional):</label>
                <input type="number" id="target-wpm" min="10" max="200" placeholder="e.g., 40">
            </div>

            <div class="setting-group">
                <label for="target-accuracy">Your Target Accuracy % (Optional):</label>
                <input type="number" id="target-accuracy" min="50" max="100" placeholder="e.g., 95">
            </div>

            <div class="setting-group">
                <label for="story-type">Story Type:</label>
                <select id="story-type">
                    <option value="random-words" selected>Random Words (Default)</option>
                    <option value="ai-story">AI Generated Story (Requires Backend)</option>
                </select>
            </div>

            <div class="button-group">
                <button class="button primary" id="save-settings-button">Start Test</button>
                <button class="button secondary" id="skip-settings-button">Skip & Start Default</button>
            </div>
        </div>
    </div>

    <div class="container content-hidden" id="main-content">
        <h1>Advanced English Typing Test</h1>

        <div class="stats top-stats">
            <div class="stat-item">
                <h3>Speed (WPM)</h3>
                <p id="wpm">0</p>
            </div>
            <div class="stat-item">
                <h3>Accuracy (%)</h3>
                <p id="accuracy">0</p>
            </div>
            <div class="stat-item">
                <h3>Errors</h3>
                <p id="errors">0</p>
            </div>
            <div class="stat-item timer-item">
                <h3>Time Left</h3>
                <p id="countdown">00:00</p>
            </div>
        </div>

        <div class="test-area" id="test-area">
            </div>

        <input type="text" id="typing-input" placeholder="Start typing here...">

        <div class="controls">
            <button class="button primary" id="restart-button">Restart Test</button>
            <button class="button secondary" id="settings-button">Settings</button>
        </div>

        <div class="result-modal" id="result-modal">
            <div class="modal-content">
                <h2>Test Results</h2>
                <div class="stats">
                    <div class="stat-item">
                        <h3>Final Speed (WPM)</h3>
                        <p id="final-wpm">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final Accuracy (%)</h3>
                        <p id="final-accuracy">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Total Errors</h3>
                        <p id="final-errors">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Raw WPM</h3>
                        <p id="raw-wpm">0</p>
                    </div>
                    <div class="stat-item target-status" id="wpm-target-status">
                        <h3>WPM Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                    <div class="stat-item target-status" id="accuracy-target-status">
                        <h3>Accuracy Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                </div>
                <button class="button primary" id="modal-restart-button">Restart Test</button>
                <button class="button secondary" id="modal-settings-button">New Test with Settings</button>
            </div>
        </div>
    </div>

    <script>
        // Function to fetch AI-generated stories (simulated for now)
        async function fetchAIGeneratedStory(lengthCategory = 'medium') {
            // In a real application, this would be an API call to your backend
            // For GitHub Pages, you'd need to deploy a backend (e.g., on Render)
            // and replace this with your actual API endpoint.
            // Example: const response = await fetch('YOUR_BACKEND_API_ENDPOINT/generate-story', {
            //    method: 'POST',
            //    headers: { 'Content-Type': 'application/json' },
            //    body: JSON.stringify({ length: lengthCategory })
            // });
            // const data = await response.json();
            // return data.story;

            // --- MOCK AI GENERATION FOR FRONTEND ONLY ---
            // Since we can't run real AI on GitHub Pages without a backend,
            // we'll simulate it by picking a longer random passage from a predefined list.
            const longStories = [
                "In a quaint village nestled between rolling hills and a winding river, lived a curious young inventor named Elara. Her days were spent tinkering with gears, wires, and strange contraptions in her small, cluttered workshop. The villagers often chuckled at her eccentricities, but they also secretly admired her unwavering dedication. One day, a fierce storm swept through the valley, knocking out power and isolating the village. Elara, with a twinkle in her eye, knew this was her moment to shine. She unveiled her latest invention: a device that could harness the raw energy of the storm itself, providing light and warmth to every home. With a flick of a switch, the village square lit up, casting a warm glow that banished the darkness and brought hope to the hearts of the people. From that day forward, Elara was no longer just a curious inventor; she was their beacon of light.",
                "The ancient library was a labyrinth of forgotten knowledge, its shelves stretching towards a vaulted ceiling, filled with books bound in leather and imbued with the scent of aged paper. Maya, an aspiring historian, had always dreamed of uncovering its secrets. Legend spoke of a hidden chamber, accessible only to those who could decipher the riddles woven into the very architecture of the building. Armed with a dusty map and her keen intellect, Maya spent weeks tracing symbols and solving puzzles, her fingers trailing over forgotten inscriptions. Finally, a section of the wall receded with a soft click, revealing a spiral staircase descending into darkness. Below, she found not gold or jewels, but a single, illuminated tome, its pages filled with the true history of their world, a history far grander and more intricate than any she had ever read.",
                "The city of Neo-Veridia hummed with the silent thrum of hover-cars and the glow of holographic advertisements. Humans and advanced AI lived side-by-side, their lives intertwined in a complex dance of technology and tradition. Kael, a data archivist, spent his days sifting through digital remnants of the past, seeking patterns and anomalies. One evening, he stumbled upon a peculiar data stream – an encrypted message from an unknown source, speaking of a long-lost natural world, untouched by urbanization. Driven by an insatiable curiosity, Kael followed the digital breadcrumbs, leading him to an ancient, forgotten port where a single, dilapidated spacecraft awaited. It was a journey into the unknown, a quest to find the whispered legends of green forests, blue oceans, and the untamed beauty of a world before concrete and chrome."
            ];
            const shortStories = [
                "The cat slept soundly by the fire, purring softly. A gentle rain fell outside, tapping on the windowpane. Soon, morning light would fill the room, waking the house. Life was simple and good.",
                "A tiny seed lay buried deep in the earth, dreaming of the sun. Slowly, it pushed a root down and a sprout up. Green leaves unfurled, reaching for the sky. It grew into a strong oak tree.",
                "The old lighthouse stood tall against the stormy sea, its beam cutting through the fog. For generations, it guided ships safely to shore. A silent guardian, it watched over the waves.",
                "She picked up her brush and dabbed paint onto the canvas. Colors swirled, forming landscapes and dreams. Each stroke brought a new world to life, born from her imagination and skill."
            ];
            const randomWordList = [
                "the", "quick", "brown", "fox", "jumps", "over", "lazy", "dog", "typing", "practice", "keyboard", "speed", "accuracy", "challenge", "learn", "javascript", "html", "css", "web", "development", "program", "computer", "science", "internet", "browser", "editor", "function", "variable", "element", "document", "style", "console", "terminal", "algorithm", "data", "structure", "network", "server", "client", "request", "response", "protocol", "security", "encryption", "database", "query", "framework", "library", "component", "module", "package", "version", "control", "repository", "commit", "branch", "merge", "pull", "push", "remote", "local", "online", "offline", "connect", "disconnect", "upload", "download", "install", "update", "delete", "create", "read", "write", "execute", "debug", "test", "deploy", "monitor", "optimize", "scale", "automate", "build", "run", "stop", "start", "restart", "configure", "setup", "manage", "organize", "design", "develop", "implement", "maintain", "support", "troubleshoot", "resolve", "solution", "problem", "issue", "error", "warning", "success", "failure", "progress", "status", "report", "log", "history", "analytics", "metric", "performance", "resource", "memory", "cpu", "disk", "bandwidth", "latency", "throughput", "reliability", "availability", "scalability", "maintainability", "usability", "flexibility", "extensibility", "portability", "security", "integrity", "confidentiality", "authentication", "authorization", "audit", "compliance", "regulation", "standard", "guideline", "best", "practice", "pattern", "design", "architecture", "model", "diagram", "flowchart", "pseudocode", "documentation", "comment", "refactor", "optimize", "debug", "test", "deploy", "monitor", "optimize", "scale", "automate", "build", "run", "stop", "start", "restart", "configure", "setup", "manage", "organize", "design", "develop", "implement", "maintain", "support", "troubleshoot", "resolve", "solution", "problem", "issue", "error", "warning", "success", "failure", "progress", "status", "report", "log", "history", "analytics", "metric", "performance", "resource", "memory", "cpu", "disk", "bandwidth", "latency", "throughput", "reliability", "availability", "scalability", "maintainability", "usability", "flexibility", "extensibility", "portability", "security", "integrity", "confidentiality", "authentication", "authorization", "audit", "compliance", "regulation", "standard", "guideline", "best", "practice", "pattern", "design", "architecture", "model", "diagram", "flowchart", "pseudocode", "documentation", "comment", "refactor", "optimize", "debug", "test", "deploy", "monitor", "alert", "log", "trace", "profile", "benchmark", "analysis", "report", "summary", "detail", "overview", "context", "scope", "requirement", "specification", "feature", "bug", "fix", "patch", "release", "version", "update", "upgrade", "downgrade", "install", "uninstall", "setup", "configure", "customize", "personalize", "settings", "options", "preferences", "profile", "account", "user", "admin", "guest", "role", "permission", "access", "control", "security", "privacy", "data", "information", "knowledge", "wisdom", "intelligence", "learning", "education", "training", "course", "lesson", "tutorial", "guide", "manual", "book", "article", "blog", "forum", "community", "support", "help", "faq", "troubleshoot", "debug", "solve", "resolve", "fix", "repair", "restore", "backup", "recover", "archive", "compress", "decompress", "encrypt", "decrypt", "hash", "checksum", "validate", "verify", "authenticate", "authorize", "grant", "revoke", "deny", "allow", "enable", "disable", "toggle", "switch", "activate", "deactivate", "start", "stop", "pause", "resume", "cancel", "abort", "retry", "redo", "undo", "save", "load", "open", "close", "new", "edit", "delete", "copy", "cut", "paste", "select", "all", "clear", "reset", "submit", "send", "receive", "download", "upload", "import", "export", "share", "print", "preview", "zoom", "in", "out", "fit", "width", "height", "actual", "size", "fullscreen", "exit", "search", "filter", "sort", "group", "categorize", "tag", "label", "mark", "favorite", "bookmark", "pin", "hide", "show", "collapse", "expand", "move", "rename", "duplicate", "clone", "merge", "split", "join", "combine", "separate", "extract", "insert", "remove", "replace", "find", "replace", "goto", "line", "column", "character", "word", "sentence", "paragraph", "document", "file", "folder", "directory", "path", "url", "uri", "urn", "protocol", "host", "port", "query", "fragment", "scheme", "authority", "userinfo", "hostname", "pathname", "search", "hash", "origin", "protocol", "domain", "subdomain", "top-level", "second-level", "country-code", "generic", "reserved", "public", "private", "local", "global", "internal", "external", "remote", "cloud", "on-premise", "hybrid", "distributed", "centralized", "decentralized", "peer-to-peer", "client-server", "front-end", "back-end", "full-stack", "desktop", "mobile", "web", "native", "cross-platform", "hybrid", "responsive", "adaptive", "fluid", "fixed", "grid", "flexbox", "bootstrap", "material", "design", "ui", "ux", "interface", "experience", "interaction", "usability", "accessibility", "performance", "security", "scalability", "reliability", "availability", "maintainability", "testability", "extensibility", "flexibility", "portability", "reusability", "modularity", "simplicity", "consistency", "efficiency", "robustness", "error-handling", "logging", "monitoring", "debugging", "testing", "deployment", "automation", "scripting", "programming", "coding", "software", "hardware", "firmware", "middleware", "operating", "system", "kernel", "shell", "command", "line", "interface", "graphical", "user", "interface", "api", "sdk", "library", "framework", "tool", "utility", "application", "program", "service", "daemon", "process", "thread", "concurrency", "parallelism", "synchronization", "asynchronous", "callback", "promise", "async", "await", "event", "loop", "queue", "stack", "heap", "tree", "graph", "linked", "list", "array", "object", "map", "set", "iterator", "generator", "decorator", "closure", "higher-order", "function", "pure", "function", "side-effect", "idempotent", "immutable", "mutable", "state", "stateless", "stateful", "component", "props", "state", "lifecycle", "hook", "context", "provider", "consumer", "reducer", "action", "dispatch", "store", "subscribe", "unsubscribe", "middleware", "thunk", "saga", "redux", "mobx", "vuex", "angular", "react", "vue", "jquery", "lodash", "underscore", "moment", "date-fns", "axios", "fetch", "websocket", "socket.io", "graphql", "rest", "api", "json", "xml", "yaml", "csv", "tsv", "markdown", "html", "css", "javascript", "typescript", "python", "java", "csharp", "go", "rust", "php", "ruby", "swift", "kotlin", "scala", "haskell", "clojure", "lisp", "erlang", "elixir", "perl", "bash", "shell", "powershell", "sql", "nosql", "mongodb", "postgresql", "mysql", "sqlite", "redis", "cassandra", "elasticsearch", "kafka", "rabbit", "mq", "aws", "azure", "gcp", "docker", "kubernetes", "git", "github", "gitlab", "bitbucket", "jenkins", "travis", "ci", "circleci", "github", "actions", "azure", "devops", "jira", "trello", "asana", "slack", "discord", "zoom", "google", "meet", "microsoft", "teams", "outlook", "gmail", "calendar", "drive", "docs", "sheets", "slides", "forms", "maps", "youtube", "twitter", "facebook", "instagram", "linkedin", "snapchat", "tiktok", "reddit", "pinterest", "whatsapp", "telegram", "signal", "viber", "wechat", "line", "skype", "facetime", "imessage", "sms", "email", "phone", "call", "video", "audio", "text", "message", "chat", "group", "channel", "thread", "notification", "alert", "badge", "icon", "button", "link", "input", "text", "area", "checkbox", "radio", "select", "option", "dropdown", "slider", "range", "progress", "bar", "spinner", "loader", "tooltip", "popover", "modal", "dialog", "accordion", "tabs", "carousel", "pagination", "breadcrumb", "navbar", "sidebar", "footer", "header", "main", "section", "article", "aside", "figure", "figcaption", "details", "summary", "dialog", "menu", "item", "list", "unordered", "ordered", "definition", "table", "row", "column", "cell", "caption", "thead", "tbody", "tfoot", "form", "fieldset", "legend", "label", "input", "textarea", "button", "select", "option", "datalist", "output", "meter", "progress", "img", "picture", "source", "svg", "canvas", "audio", "video", "track", "embed", "iframe", "object", "param", "map", "area", "link", "meta", "style", "script", "noscript", "template", "slot", "abbr", "address", "b", "bdi", "bdo", "blockquote", "cite", "code", "del", "dfn", "em", "i", "ins", "kbd", "mark", "q", "rp", "rt", "rtc", "ruby", "s", "samp", "small", "span", "strong", "sub", "sup", "time", "u", "var", "wbr", "acronym", "applet", "basefont", "big", "center", "dir", "font", "frame", "frameset", "noframes", "strike", "tt"
            ];
            // If random-words is selected, we combine words to form a longer story for variety
            if (lengthCategory === 'random-words') {
                let generatedText = "";
                const targetWordCount = 200 * (testDurationSelect.value / 5); // Roughly adjust words based on duration
                for (let i = 0; i < targetWordCount; i++) {
                    generatedText += randomWordList[Math.floor(Math.random() * randomWordList.length)] + " ";
                }
                return generatedText.trim();
            } else if (lengthCategory === 'short') {
                return shortStories[Math.floor(Math.random() * shortStories.length)];
            } else if (lengthCategory === 'long') {
                return longStories[Math.floor(Math.random() * longStories.length)];
            } else { // 'medium' or default AI story
                return "The sun dipped below the horizon, painting the sky in hues of orange and purple. A lone bird soared across the fading light, its wings catching the last rays. Below, the city lights began to twinkle, promising a night of bustling activity. A gentle breeze carried the scent of blooming jasmine through the open window. It was a perfect evening to reflect on the day's events and anticipate the quiet hours ahead. The world felt at peace, a symphony of subtle changes unfolding as darkness embraced the landscape, bringing with it the promise of a new dawn and fresh opportunities. Every moment held a quiet beauty, a fleeting perfection that made the heart sing with gratitude for its simple existence.";
            }
        }
        // --- END MOCK AI GENERATION ---

        // DOM Elements
        const mainContent = document.getElementById('main-content');
        const testArea = document.getElementById('test-area');
        const typingInput = document.getElementById('typing-input');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const errorsDisplay = document.getElementById('errors');
        const countdownDisplay = document.getElementById('countdown');
        const restartButton = document.getElementById('restart-button');
        const settingsButton = document.getElementById('settings-button');
        const resultModal = document.getElementById('result-modal');
        const finalWpmDisplay = document.getElementById('final-wpm');
        const finalAccuracyDisplay = document.getElementById('final-accuracy');
        const finalErrorsDisplay = document.getElementById('final-errors');
        const rawWpmDisplay = document.getElementById('raw-wpm');
        const modalRestartButton = document.getElementById('modal-restart-button');
        const modalSettingsButton = document.getElementById('modal-settings-button');

        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settings-overlay');
        const testDurationSelect = document.getElementById('test-duration');
        const targetWpmInput = document.getElementById('target-wpm');
        const targetAccuracyInput = document.getElementById('target-accuracy');
        const storyTypeSelect = document.getElementById('story-type');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const skipSettingsButton = document.getElementById('skip-settings-button');
        const wpmTargetStatus = document.getElementById('wpm-target-status');
        const accuracyTargetStatus = document.getElementById('accuracy-target-status');


        // Global Variables
        let testWords = [];
        let wordIndex = 0;
        let charIndex = 0; // Not strictly used for char tracking, but good practice
        let startTime;
        let timerInterval;
        let defaultTestDuration = 5 * 60; // Default 5 minutes in seconds
        let timeLeft = defaultTestDuration;
        let correctChars = 0;
        let incorrectChars = 0;
        let typedCharsOverall = 0; // Total characters typed including errors and backspaces

        let userTargetWPM = null;
        let userTargetAccuracy = null;
        let currentStoryType = 'random-words';

        // Utility to format time
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        async function generateAndRenderTestWords() {
            testWords = [];
            let textToType = "";

            if (currentStoryType === 'ai-story') {
                let lengthCategory = 'medium'; // Default for AI story
                const durationMinutes = parseInt(testDurationSelect.value);
                if (durationMinutes <= 2) {
                    lengthCategory = 'short';
                } else if (durationMinutes >= 10) {
                    lengthCategory = 'long';
                }
                textToType = await fetchAIGeneratedStory(lengthCategory);
            } else { // random-words
                textToType = await fetchAIGeneratedStory('random-words'); // Use the same function for random words now
            }

            testWords = textToType.split(' '); // Split by space to get words

            testArea.innerHTML = '';
            testWords.forEach((word, wordIdx) => {
                const wordSpan = document.createElement('span');
                wordSpan.classList.add('word');
                word.split('').forEach(char => {
                    const charSpan = document.createElement('span');
                    charSpan.textContent = char;
                    charSpan.classList.add('untyped');
                    wordSpan.appendChild(charSpan);
                });
                // Add a space span after each word (except the last one)
                if (wordIdx < testWords.length - 1) {
                    const spaceSpan = document.createElement('span');
                    spaceSpan.textContent = ' ';
                    spaceSpan.classList.add('char-space'); // Unique class for space char
                    spaceSpan.classList.add('untyped');
                    wordSpan.appendChild(spaceSpan);
                }
                testArea.appendChild(wordSpan);
            });
            highlightCurrentWord();
            adjustTestAreaScroll(); // Adjust scroll initially
        }


        function highlightCurrentWord() {
            const allWordSpans = testArea.querySelectorAll('.word');
            allWordSpans.forEach((span, idx) => {
                if (idx === wordIndex) {
                    span.classList.add('current-word');
                } else {
                    span.classList.remove('current-word');
                }
            });
            adjustTestAreaScroll();
        }

        // Function to automatically scroll the test area
        function adjustTestAreaScroll() {
            const currentWordSpan = testArea.children[wordIndex];
            if (!currentWordSpan) return;

            const testAreaRect = testArea.getBoundingClientRect();
            const wordRect = currentWordSpan.getBoundingClientRect();

            // Calculate vertical scroll
            // Check if the word is below the visible area
            if (wordRect.bottom > testAreaRect.bottom) {
                testArea.scrollTop += (wordRect.bottom - testAreaRect.bottom) + 10; // Scroll down by diff + a little buffer
            }
            // Check if the word is above the visible area (e.g., after a backspace or reset, or re-render)
            else if (wordRect.top < testAreaRect.top) {
                testArea.scrollTop -= (testAreaRect.top - wordRect.top) + 10; // Scroll up by diff + a little buffer
            }
        }


        function updateStats() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            if (timeElapsed === 0) return; // Avoid division by zero at start

            const minutesElapsed = timeElapsed / 60;

            // WPM calculation: (Correct Characters / 5) / (Time in Minutes)
            const currentWPM = Math.round((correctChars / 5) / minutesElapsed);
            wpmDisplay.textContent = isNaN(currentWPM) ? 0 : currentWPM;

            const currentAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            accuracyDisplay.textContent = isNaN(currentAccuracy) ? 0 : currentAccuracy;
            errorsDisplay.textContent = incorrectChars;
        }


        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = formatTime(timeLeft);
                updateStats();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endTest();
                }
            }, 1000);
        }

        function endTest() {
            typingInput.disabled = true;
            typingInput.value = '';
            clearInterval(timerInterval);
            updateStats(); // Final update

            const timeElapsed = (defaultTestDuration - timeLeft);
            const finalMinutesElapsed = timeElapsed / 60;

            // Handle potential division by zero if test ended immediately for some reason
            const finalWPM = finalMinutesElapsed > 0 ? Math.round((correctChars / 5) / finalMinutesElapsed) : 0;
            const finalAccuracy = typedCharsOverall === 0 ? 0 : Math.round((correctChars / typedCharsOverall) * 100);
            const finalRawWPM = finalMinutesElapsed > 0 ? Math.round((typedCharsOverall / 5) / finalMinutesElapsed) : 0;


            finalWpmDisplay.textContent = isNaN(finalWPM) ? 0 : finalWPM;
            finalAccuracyDisplay.textContent = isNaN(finalAccuracy) ? 0 : finalAccuracy;
            finalErrorsDisplay.textContent = incorrectChars;
            rawWPMDisplay.textContent = isNaN(finalRawWPM) ? 0 : finalRawWPM;

            // Check and update target status
            if (userTargetWPM !== null && !isNaN(userTargetWPM)) {
                if (finalWPM >= userTargetWPM) {
                    wpmTargetStatus.querySelector('p').textContent = `Met (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    wpmTargetStatus.querySelector('p').textContent = `Missed (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                wpmTargetStatus.querySelector('p').textContent = 'N/A';
                wpmTargetStatus.querySelector('p').className = 'status-neutral';
            }

            if (userTargetAccuracy !== null && !isNaN(userTargetAccuracy)) {
                if (finalAccuracy >= userTargetAccuracy) {
                    accuracyTargetStatus.querySelector('p').textContent = `Met (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    accuracyTargetStatus.querySelector('p').textContent = `Missed (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                accuracyTargetStatus.querySelector('p').textContent = 'N/A';
                accuracyTargetStatus.querySelector('p').className = 'status-neutral';
            }

            resultModal.classList.add('show');
            // Allow restart and settings access after test ends
            restartButton.disabled = false;
            settingsButton.disabled = false;
        }

        async function initializeTest(duration, targetWPM, targetAccuracy, storyType) {
            clearInterval(timerInterval);
            defaultTestDuration = duration * 60; // Convert minutes to seconds
            timeLeft = defaultTestDuration;
            countdownDisplay.textContent = formatTime(timeLeft);
            wordIndex = 0;
            charIndex = 0;
            correctChars = 0;
            incorrectChars = 0;
            typedCharsOverall = 0;
            typingInput.value = '';
            typingInput.disabled = false;
            startTime = null; // Reset start time
            
            userTargetWPM = targetWPM ? parseInt(targetWPM) : null;
            userTargetAccuracy = targetAccuracy ? parseInt(targetAccuracy) : null;
            currentStoryType = storyType;

            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '0';
            errorsDisplay.textContent = '0';

            // Ensure buttons are clickable for a new test or settings
            restartButton.disabled = false; 
            settingsButton.disabled = false;
            
            await generateAndRenderTestWords(); // Generate new words based on settings
            typingInput.focus();
            resultModal.classList.remove('show');
            settingsOverlay.classList.remove('show'); // Hide settings overlay
            mainContent.classList.remove('content-hidden'); // Show main content
        }

        // Event Listeners

        // Typing Input Listener
        typingInput.addEventListener('input', (e) => {
            if (!startTime) {
                startTimer(); // Start timer on first input
            }
            
            const currentWordExpected = testWords[wordIndex];
            const typedText = e.target.value;
            const currentWordSpan = testArea.children[wordIndex];

            if (!currentWordSpan) { // No more words to type
                endTest();
                return;
            }

            // Get all character spans including the potential space span
            const charSpans = Array.from(currentWordSpan.children); 

            // Update char rendering within the current word
            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                const charSpan = charSpans[i];

                if (charSpan) {
                    charSpan.classList.remove('correct', 'incorrect', 'untyped', 'extra');
                    if (typedChar === undefined) {
                        charSpan.classList.add('untyped');
                    } else if (typedChar === charExpected) {
                        charSpan.classList.add('correct');
                    } else {
                        charSpan.classList.add('incorrect');
                    }
                }
            }

            // Handle the space character
            const spaceSpan = charSpans[currentWordExpected.length]; // This should be the space span
            if (spaceSpan && spaceSpan.classList.contains('char-space')) {
                spaceSpan.classList.remove('correct', 'incorrect', 'untyped');
                if (typedText[currentWordExpected.length] === ' ') {
                    spaceSpan.classList.add('correct');
                } else if (typedText[currentWordExpected.length] !== undefined) {
                    spaceSpan.classList.add('incorrect');
                } else {
                    spaceSpan.classList.add('untyped');
                }
            }


            // Handle extra characters typed (beyond the current word's length AND space)
            for (let i = currentWordExpected.length + 1; i < charSpans.length; i++) {
                charSpans[i].style.display = 'none'; // Hide any previously displayed 'extra' characters
            }
            for (let i = currentWordExpected.length + 1; i < typedText.length; i++) {
                let extraSpan = charSpans[i];
                if (!extraSpan) { // Create if it doesn't exist
                    extraSpan = document.createElement('span');
                    currentWordSpan.appendChild(extraSpan);
                }
                extraSpan.textContent = typedText[i];
                extraSpan.classList.add('extra');
                extraSpan.style.display = 'inline-block';
            }

            // Update typedCharsOverall for real-time accuracy and raw WPM
            // This needs to correctly account for backspaces as well.
            // A simple way is to re-calculate it or adjust based on input type.
            const previousTypedCharsOverall = typedCharsOverall; // Store for comparison
            typedCharsOverall = e.target.value.length; // Characters in current input
            
            // Adjust for total characters typed considering backspaces and completed words
            // This logic is tricky. A more robust way is to count actual correct/incorrect typed chars.
            // For now, let's update correctChars and incorrectChars based on the current word's state.

            let newCorrectChars = 0;
            let newIncorrectChars = 0;

            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                if (typedChar === charExpected) {
                    newCorrectChars++;
                } else if (typedChar !== undefined) {
                    newIncorrectChars++;
                }
            }

            // Account for the space at the end of the word if typed
            if (typedText.length > currentWordExpected.length) {
                if (typedText[currentWordExpected.length] === ' ') {
                    newCorrectChars++;
                } else {
                    newIncorrectChars++;
                }
            }

            // This approach is simplified and might not be perfect for every backspace scenario
            // For robust accuracy, you'd track character-by-character changes and tally.
            // For this single-file setup, we'll keep it simple for now.

            // If word is completed (space or Enter pressed)
            if (typedText.endsWith(' ')) {
                const currentWordActual = currentWordExpected;
                const typedWord = typedText.trim(); // Remove trailing space

                // Recalculate correct and incorrect for the *entire* word + space before advancing
                let tempCorrectChars = 0;
                let tempIncorrectChars = 0;

                for (let i = 0; i < currentWordActual.length; i++) {
                    if (typedWord[i] === currentWordActual[i]) {
                        tempCorrectChars++;
                    } else if (typedWord[i] !== undefined) {
                        tempIncorrectChars++;
                    }
                }
                
                // Account for the space character
                if (typedText.length > currentWordActual.length) { // Means space was typed or extra char
                     if (typedText[currentWordActual.length] === ' ') {
                        tempCorrectChars++; // Correct space
                    } else {
                        tempIncorrectChars++; // Something else typed instead of space
                    }
                } else { // Word typed without space, but space was expected
                    tempIncorrectChars++; // Omitted space
                }

                // Add errors for extra characters typed beyond expected word + space
                if (typedText.length > currentWordActual.length + 1) { // If more than word and 1 space
                    tempIncorrectChars += (typedText.length - (currentWordActual.length + 1));
                }

                correctChars += tempCorrectChars;
                incorrectChars += tempIncorrectChars;
                typedCharsOverall += typedText.length; // Count all characters actually typed for this word

                wordIndex++; // Move to next word
                typingInput.value = ''; // Clear input for next word
                highlightCurrentWord(); // Update highlighting and scroll

                if (wordIndex >= testWords.length) { // End test if all words are typed
                    endTest();
                    return;
                }
            }

            updateStats(); // Update stats in real-time
        });


        restartButton.addEventListener('click', () => {
            // Show settings overlay on restart
            settingsOverlay.classList.add('show');
            resultModal.classList.remove('show'); // Hide result modal if open
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
        });

        settingsButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
        });

        saveSettingsButton.addEventListener('click', () => {
            const duration = parseInt(testDurationSelect.value);
            const targetWPM = targetWpmInput.value;
            const targetAccuracy = targetAccuracyInput.value;
            const storyType = storyTypeSelect.value;
            initializeTest(duration, targetWPM, targetAccuracy, storyType);
        });

        skipSettingsButton.addEventListener('click', () => {
            initializeTest(5, null, null, 'random-words'); // Default to 5 mins, no targets, random words
        });

        modalRestartButton.addEventListener('click', () => {
            initializeTest(defaultTestDuration / 60, userTargetWPM, userTargetAccuracy, currentStoryType); // Use current settings for restart
        });

        modalSettingsButton.addEventListener('click', () => {
            resultModal.classList.remove('show');
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); // Hide main content
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            settingsOverlay.classList.add('show');
            // Hide main content initially
            mainContent.classList.add('content-hidden');
            countdownDisplay.textContent = formatTime(defaultTestDuration); // Show initial default time
        });

    </script>
</body>
</html>
