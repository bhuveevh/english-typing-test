<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced English Typing Test for Govt. Jobs</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Montserrat:wght=400;700&family=Source+Code+Pro:wght=400;700&family=Open+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic Reset & Font Imports */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #e3f2fd; /* Light Blue background */
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align at the top */
            min-height: 100vh;
            padding: 20px;
            background: linear-gradient(to right, #e3f2fd, #fce4ec); /* Light Blue to Light Pink Gradient */
        }

        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 16px; /* Slightly more rounded */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15); /* More prominent shadow */
            width: 100%;
            max-width: 900px;
            animation: fadeIn 0.8s ease-out;
            border: 1px solid #bbdefb; /* Light blue border */
            position: relative; /* For z-index to work with settings overlay */
            z-index: 1; /* Ensure container is above other elements when settings are hidden */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h1 {
            text-align: center;
            color: #e91e63; /* Pink primary color */
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.5em; /* Larger title */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }

        /* Live Stats Area (moved to top) */
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px; /* Space below stats */
            flex-wrap: wrap;
            gap: 15px;
            background-color: #fce4ec; /* Light pink background */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        }

        .stat-item {
            background-color: #fff;
            padding: 12px 18px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            text-align: center;
            min-width: 120px;
            flex: 1;
            border: 1px solid #f8bbd0; /* Slightly darker pink border */
        }

        .stat-item h3 {
            color: #6a1b9a; /* Deep purple for sub-headers */
            font-size: 1em;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .stat-item p {
            font-size: 1.8em; /* Slightly smaller for compactness */
            font-weight: bold;
            color: #e91e63; /* Pink for values */
            font-family: 'Montserrat', sans-serif;
        }

        .timer-item p {
            color: #2196f3; /* Blue for timer */
        }
        
        /* New: Live CPM display style */
        .cpm-item p {
            color: #ff9800; /* Orange for CPM */
        }

        /* New: KDPH display style */
        .kdph-item p {
            color: #8bc34a; /* Light green for KDPH */
        }


        /* Test Area */
        .test-area {
            margin-bottom: 20px; /* Reduced margin */
            padding: 20px;
            background-color: #f1f8e9; /* Very light green for contrast */
            border-radius: 10px;
            border: 1px solid #dcedc8;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            min-height: 120px; /* Smaller height */
            max-height: 120px; /* Fixed height for 3 lines */
            overflow: hidden; /* Hide overflow */
            position: relative;
            line-height: 1.8; /* More spacing for readability */
            font-size: 1.2em; /* Slightly smaller font for more words per line */
            font-family: 'Open Sans', sans-serif; /* Changed to Open Sans for better readability */
            color: #444;
        }

        /* For handling paragraphs and line breaks in test-area */
        .paragraph {
            margin-bottom: 1.5em; /* Space between paragraphs */
            white-space: pre-wrap; /* Preserves whitespace and wraps text */
        }

        .word {
            display: inline-block;
            margin-right: 5px;
            padding: 1px 0;
            white-space: pre-wrap; /* Ensure words don't break mid-char for spaces */
        }
        
        /* New: Visual representation for newline character for user awareness */
        .newline-marker {
            display: inline-block;
            width: 20px; /* Width to resemble a small 'enter' key */
            height: 18px; /* Height */
            background-color: #cfd8dc; /* Light grey */
            border-radius: 3px;
            margin-left: 5px; /* Space from previous word */
            margin-right: 5px;
            vertical-align: middle;
            text-align: center;
            font-size: 0.8em;
            color: #607d8b;
            line-height: 18px; /* Center text vertically */
            position: relative;
            top: -2px; /* Adjust vertical position */
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .newline-marker::after {
            content: "⏎"; /* Enter symbol */
        }


        .current-word {
            background-color: #fff9c4; /* Light yellow for current word */
            border-radius: 4px;
            padding: 1px 5px;
            box-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
        }
        /* New: Highlight for current newline marker */
        .current-newline-marker {
            background-color: #fff9c4; /* Match word highlight */
            border: 1px solid #ffeb3b; /* Stronger border */
            box-shadow: 0 0 5px rgba(255, 235, 59, 0.5);
        }

        .correct {
            color: #388e3c; /* Dark green for correct */
        }

        .incorrect {
            color: #d32f2f; /* Dark red for incorrect */
            text-decoration: underline wavy #d32f2f 2px;
        }

        .extra {
            color: #7b7b7b;
            background-color: #ffebee; /* Very light red background for extra */
            border-radius: 3px;
            padding: 0 2px;
        }

        .untyped {
            color: #7b7b7b;
        }

        /* Input Area */
        #typing-input {
            width: 100%;
            padding: 15px 20px;
            font-size: 1.5em;
            border: 2px solid #ccc;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Source Code Pro', monospace; /* Kept monospace for input */
            background-color: #fcfcfc;
            margin-bottom: 20px; /* Space below input */
        }

        #typing-input:focus {
            border-color: #2196f3; /* Blue on focus */
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
        }

        /* Controls */
        .controls {
            text-align: center;
            margin-top: 20px; /* Reduced margin */
        }

        .button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px; /* Slightly more rounded buttons */
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            margin: 0 10px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
        }

        .button.primary {
            background-color: #e91e63; /* Pink primary */
            color: white;
            box-shadow: 0 4px 8px rgba(233, 30, 99, 0.2);
        }

        .button.primary:hover {
            background-color: #d81b60; /* Darker pink on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(233, 30, 99, 0.3);
        }

        .button.secondary {
            background-color: #2196f3; /* Blue secondary */
            color: white;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.2);
        }

        .button.secondary:hover {
            background-color: #1976d2; /* Darker blue on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(33, 150, 243, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Result Modal */
        .result-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }

        .result-modal.show {
            visibility: visible;
            opacity: 1;
        }

        .modal-content {
            background-color: #fff;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            max-width: 600px; /* Wider modal */
            width: 90%;
            border: 1px solid #bbdefb;
        }

        .result-modal.show .modal-content {
            transform: scale(1);
        }

        .modal-content h2 {
            color: #e91e63;
            margin-bottom: 25px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2em;
        }

        .modal-content .stats {
            flex-wrap: wrap; /* Ensure wrapping in modal too */
            justify-content: center;
            margin-bottom: 20px;
        }

        .modal-content .stat-item {
            margin-bottom: 15px;
            background-color: #e3f2fd; /* Light blue in modal stats */
            border: 1px solid #90caf9;
        }

        /* Result Colors */
        .result-value-green {
            color: #388e3c; /* Green for good results (WPM, Accuracy) */
        }
        .result-value-red {
            color: #d32f2f; /* Red for bad results (Errors) */
        }
        .result-value-orange {
            color: #ff9800; /* Orange for CPM */
        }
        .result-value-purple {
            color: #6a1b9a; /* Purple for Raw WPM */
        }
        .result-value-kdph {
            color: #8bc34a; /* Light green for KDPH */
        }


        .modal-content .button {
            margin-top: 25px;
            margin: 10px; /* Space between modal buttons */
        }

        /* Target Status in Modal */
        .stat-item.target-status p {
            font-size: 1.5em; /* Smaller font for target status */
        }
        .status-neutral { color: #607d8b; } /* Grey */
        .status-met { color: #388e3c; } /* Green */
        .status-not-met { color: #d32f2f; } /* Red */


        /* New: Detailed Error Stats in Modal */
        .error-details {
            margin-top: 20px;
            text-align: left;
            background-color: #ffebee; /* Light red background for error section */
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ef9a9a;
        }

        .error-details h3 {
            color: #d32f2f;
            font-size: 1.2em;
            margin-bottom: 10px;
            text-align: center;
        }

        .error-details ul {
            list-style: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px 20px; /* Row and column gap */
        }

        .error-details li {
            font-size: 1em;
            color: #424242;
            flex-basis: 45%; /* Two columns */
            white-space: nowrap; /* Prevent wrapping for each stat */
        }

        .error-details li strong {
            color: #d32f2f;
            margin-left: 5px;
        }


        /* Settings Overlay (Full-screen) */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker, more opaque background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Higher z-index than container and result modal */
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.4s ease;
        }

        .settings-overlay.show {
            visibility: visible;
            opacity: 1;
        }

        .settings-overlay .settings-content {
            background-color: #f0f4c3; /* Light yellow-green for settings */
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 90%;
            border: 1px solid #cddc39;
            transform: scale(0.9);
            transition: transform 0.4s ease;

            /* Fix for overflow on settings screen */
            max-height: 90vh; /* Limit height to 90% of viewport height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }

        .settings-overlay.show .settings-content {
            transform: scale(1);
        }

        .settings-overlay h2 {
            color: #4CAF50; /* Green for settings header */
            margin-bottom: 30px;
            font-family: 'Montserrat', sans-serif;
            font-size: 2.2em;
        }

        .setting-group {
            margin-bottom: 25px; /* More space between groups */
            text-align: left;
        }

        .setting-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px; /* More space below label */
            color: #388e3c; /* Darker green for setting labels */
            font-size: 1.15em;
        }

        .setting-group select,
        .setting-group input[type="number"] {
            width: 100%;
            padding: 12px; /* Larger padding for inputs */
            border: 1px solid #aed581; /* Greenish border */
            border-radius: 8px;
            font-size: 1.1em;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Roboto', sans-serif;
        }

        .setting-group select:focus,
        .setting-group input[type="number"]:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        /* New: Custom Story Area styles */
        #custom-story-area {
            display: none; /* Hidden by default */
            margin-top: 20px;
            border-top: 1px solid #cddc39;
            padding-top: 20px;
        }

        #custom-story-textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid #aed581;
            border-radius: 8px;
            font-size: 1.1em;
            font-family: 'Open Sans', sans-serif;
            resize: vertical;
            margin-bottom: 10px;
        }

        #custom-story-textarea:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.25);
        }

        .custom-story-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .custom-story-controls .button {
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 48%; /* Adjust for spacing */
        }
        
        @media (max-width: 480px) {
            .custom-story-controls .button {
                max-width: 100%; /* Stack buttons on very small screens */
            }
        }


        .settings-overlay .button-group {
            margin-top: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        /* Initial hidden state for the main content */
        .content-hidden {
            visibility: hidden;
            opacity: 0;
            height: 0;
            overflow: hidden;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            .stats {
                gap: 10px;
            }

            .stat-item {
                min-width: 100px;
                padding: 10px 12px;
            }

            .stat-item p {
                font-size: 1.5em;
            }

            .test-area {
                font-size: 1.1em;
                padding: 15px;
                min-height: 100px;
                max-height: 100px;
            }

            #typing-input {
                font-size: 1.2em;
                padding: 10px 15px;
            }

            .button {
                padding: 10px 20px;
                font-size: 1em;
                margin: 5px;
            }

            .modal-content {
                padding: 25px;
            }

            .modal-content h2 {
                font-size: 1.8em;
            }

            .settings-overlay .settings-content {
                padding: 25px;
            }
            .settings-overlay h2 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }
            .setting-group {
                margin-bottom: 20px;
            }
            .settings-overlay .button-group {
                flex-direction: column;
                gap: 15px;
            }
            .settings-overlay .button {
                width: 80%; /* Make buttons wider on small screens */
                margin: 0 auto;
            }

            .error-details li {
                flex-basis: 100%; /* Stack error details on small screens */
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="settings-overlay" id="settings-overlay">
        <div class="settings-content">
            <h2>Typing Test Settings</h2>
            <div class="setting-group">
                <label for="test-duration">Select Test Duration:</label>
                <select id="test-duration">
                    <option value="1">1 Minute</option>
                    <option value="2">2 Minutes</option>
                    <option value="3">3 Minutes</option>
                    <option value="5" selected>5 Minutes</option>
                    <option value="10">10 Minutes</option>
                    <option value="15">15 Minutes</option>
                    <option value="20">20 Minutes</option>
                    <option value="30">30 Minutes</option>
                </select>
            </div>

            <div class="setting-group">
                <label for="target-wpm">Your Target WPM (Optional):</label>
                <input type="number" id="target-wpm" min="10" max="200" placeholder="e.g., 40">
            </div>

            <div class="setting-group">
                <label for="target-accuracy">Your Target Accuracy % (Optional):</label>
                <input type="number" id="target-accuracy" min="50" max="100" placeholder="e.g., 95">
            </div>

            <div class="setting-group">
                <label for="story-type">Story Type:</label>
                <select id="story-type">
                    <option value="random-words" selected>Random Words (Default)</option>
                    <option value="ai-story">AI Generated Story (Requires Backend)</option>
                    <option value="user-custom">User Custom Story</option>
                </select>
            </div>

            <div id="custom-story-area">
                <label for="custom-story-textarea">Paste your story here:</label>
                <textarea id="custom-story-textarea" placeholder="Paste the text you want to type here..."></textarea>
                <div class="custom-story-controls">
                    <button class="button secondary" id="add-story-link-button">Add Story from Reedsy</button>
                </div>
            </div>

            <div class="button-group">
                <button class="button primary" id="save-settings-button">Start Test</button>
                <button class="button secondary" id="skip-settings-button">Skip & Start Default</button>
            </div>
        </div>
    </div>

    <div class="container content-hidden" id="main-content">
        <h1>Advanced English Typing Test for Govt. Jobs</h1>

        <div class="stats top-stats">
            <div class="stat-item">
                <h3>Speed (WPM)</h3>
                <p id="wpm">0</p>
            </div>
            <div class="stat-item">
                <h3>Accuracy (%)</h3>
                <p id="accuracy">0</p>
            </div>
            <div class="stat-item">
                <h3>Errors</h3>
                <p id="errors">0</p>
            </div>
            <div class="stat-item cpm-item">
                <h3>CPM</h3>
                <p id="cpm">0</p>
            </div>
            <div class="stat-item kdph-item">
                <h3>KDPH</h3>
                <p id="kdph">0</p>
            </div>
            <div class="stat-item timer-item">
                <h3>Time Left</h3>
                <p id="countdown">00:00</p>
            </div>
        </div>

        <div class="test-area" id="test-area">
            </div>

        <input type="text" id="typing-input" placeholder="Start typing here...">

        <div class="controls">
            <button class="button primary" id="restart-button">Restart Test</button>
            <button class="button secondary" id="settings-button">Settings</button>
        </div>

        <div class="result-modal" id="result-modal">
            <div class="modal-content">
                <h2>Test Results</h2>
                <div class="stats">
                    <div class="stat-item">
                        <h3>Final Speed (WPM)</h3>
                        <p id="final-wpm" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final Accuracy (%)</h3>
                        <p id="final-accuracy" class="result-value-green">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Total Errors</h3>
                        <p id="final-errors" class="result-value-red">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Raw WPM</h3>
                        <p id="raw-wpm" class="result-value-purple">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final CPM</h3>
                        <p id="final-cpm" class="result-value-orange">0</p>
                    </div>
                    <div class="stat-item">
                        <h3>Final KDPH</h3>
                        <p id="final-kdph" class="result-value-kdph">0</p>
                    </div>
                    <div class="stat-item target-status" id="wpm-target-status">
                        <h3>WPM Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                    <div class="stat-item target-status" id="accuracy-target-status">
                        <h3>Accuracy Target</h3>
                        <p class="status-neutral">N/A</p>
                    </div>
                </div>

                <div class="error-details">
                    <h3>Error Breakdown</h3>
                    <ul>
                        <li>Incorrect Characters: <strong id="err-incorrect-chars">0</strong></li>
                        <li>Missed Characters: <strong id="err-missed-chars">0</strong></li>
                        <li>Extra Characters: <strong id="err-extra-chars">0</strong></li>
                        <li>Skipped Words: <strong id="err-skipped-words">0</strong></li>
                        <li>Extra Words: <strong id="err-extra-words">0</strong></li>
                        <li>Incorrect Enter: <strong id="err-incorrect-enter">0</strong></li>
                        <li>Incorrect Space: <strong id="err-incorrect-space">0</strong></li>
                    </ul>
                </div>


                <button class="button primary" id="modal-restart-button">Restart Test</button>
                <button class="button secondary" id="modal-settings-button">New Test with Settings</button>
            </div>
        </div>
    </div>

    <script>
        // Function to fetch AI-generated stories (simulated for now)
        async function fetchAIGeneratedStory(lengthCategory = 'medium') {
            const longStories = [
                "In a quaint village nestled between rolling hills and a winding river, lived a curious young inventor named Elara. Her days were spent tinkering with gears, wires, and strange contraptions in her small, cluttered workshop. The villagers often chuckled at her eccentricities, but they also secretly admired her unwavering dedication. One day, a fierce storm swept through the valley, knocking out power and isolating the village. Elara, with a twinkle in her eye, knew this was her moment to shine. She unveiled her latest invention: a device that could harness the raw energy of the storm itself, providing light and warmth to every home. With a flick of a switch, the village square lit up, casting a warm glow that banished the darkness and brought hope to the hearts of the people. From that day forward, Elara was no longer just a curious inventor; she was their beacon of light.\n\nShe continued her work, always striving to improve her creations. The villagers, once skeptical, now sought her advice and marvelled at her ingenuity. Elara taught them about sustainable energy and the importance of innovation. Her workshop became a hub of learning, where children gathered to watch her work and ask questions. The village, once known only for its quiet charm, became a symbol of progress and self-sufficiency, all thanks to Elara's relentless pursuit of knowledge and her generous spirit. The legacy of her inventions spread far beyond the valley, inspiring other communities to embrace a future powered by clean, renewable sources. Her story became a testament to the power of one individual to change the world.",
                "The ancient library was a labyrinth of forgotten knowledge, its shelves stretching towards a vaulted ceiling, filled with books bound in leather and imbued with the scent of aged paper. Maya, an aspiring historian, had always dreamed of uncovering its secrets. Legend spoke of a hidden chamber, accessible only to those who could decipher the riddles woven into the very architecture of the building. Armed with a dusty map and her keen intellect, Maya spent weeks tracing symbols and solving puzzles, her fingers trailing over forgotten inscriptions. Finally, a section of the wall receded with a soft click, revealing a spiral staircase descending into darkness. Below, she found not gold or jewels, but a single, illuminated tome, its pages filled with the true history of their world, a history far grander and more intricate than any she had ever read.\n\nThe tome detailed ancient civilizations and their rise and fall, the forgotten technologies they wielded, and the philosophies that guided their lives. It wasn't merely a record of events, but a deep exploration of human nature itself. Maya realized the immense responsibility of this discovery. She dedicated her life to transcribing and disseminating its contents, ensuring that the knowledge would never again be lost to time. Her efforts sparked a new age of enlightenment, and humanity, armed with the wisdom of the past, began to build a better future.",
                "The city of Neo-Veridia hummed with the silent thrum of hover-cars and the glow of holographic advertisements. Humans and advanced AI lived side-by-side, their lives intertwined in a complex dance of technology and tradition. Kael, a data archivist, spent his days sifting through digital remnants of the past, seeking patterns and anomalies. One evening, he stumbled upon a peculiar data stream – an encrypted message from an unknown source, speaking of a long-lost natural world, untouched by urbanization. Driven by an insatiable curiosity, Kael followed the digital breadcrumbs, leading him to an ancient, forgotten port where a single, dilapidated spacecraft awaited. It was a journey into the unknown, a quest to find the whispered legends of green forests, blue oceans, and the untamed beauty of a world before concrete and chrome."
            ];
            const shortStories = [
                "The cat slept soundly by the fire, purring softly. A gentle rain fell outside, tapping on the windowpane. Soon, morning light would fill the room, waking the house. Life was simple and good.",
                "A tiny seed lay buried deep in the earth, dreaming of the sun. Slowly, it pushed a root down and a sprout up. Green leaves unfurled, reaching for the sky. It grew into a strong oak tree.",
                "The old lighthouse stood tall against the stormy sea, its beam cutting through the fog. For generations, it guided ships safely to shore. A silent guardian, it watched over the waves.",
                "She picked up her brush and dabbed paint onto the canvas. Colors swirled, forming landscapes and dreams. Each stroke brought a new world to life, born from her imagination and skill."
            ];
            // Updated randomWordList to include punctuation and some numbers for realism
            const randomWordList = [
                "the", "quick", "brown", "fox", "jumps", "over", "lazy", "dog.", "typing", "practice", "keyboard,", "speed", "accuracy!", "challenge", "learn", "javascript", "html", "css?", "web", "development", "program", "computer.", "science", "internet", "browser,", "editor", "function", "variable", "element?", "document", "style", "console", "terminal.", "algorithm", "data", "structure", "network!", "server", "client", "request,", "response", "protocol", "security.", "encryption", "database", "query,", "framework", "library", "component!", "module", "package", "version.", "control", "repository", "commit,", "branch", "merge", "pull?", "push", "remote", "local.", "online", "offline", "connect,", "disconnect", "upload", "download!", "install", "update", "delete.", "create", "read", "write,", "execute", "debug", "test?", "deploy", "monitor", "optimize.", "scale", "automate", "build,", "run", "stop", "start!", "restart", "configure", "setup.", "manage", "organize", "design,", "develop", "implement", "maintain?", "support", "troubleshoot", "resolve.", "solution", "problem", "issue,", "error", "warning", "success!", "failure", "progress", "status.", "report", "log", "history,", "analytics", "metric", "performance?", "resource", "memory", "cpu.", "disk", "bandwidth", "latency,", "throughput", "reliability", "availability!", "scalability", "maintainability", "usability.", "flexibility", "extensibility", "portability,", "security", "integrity", "confidentiality!", "authentication", "authorization", "audit.", "compliance", "regulation", "standard,", "guideline", "best", "practice?", "pattern", "design", "architecture.", "model", "diagram", "flowchart,", "pseudocode", "documentation", "comment!", "refactor", "optimize", "debug.", "test", "deploy", "monitor,", "alert", "log", "trace?", "profile", "benchmark", "analysis.", "report", "summary", "detail,", "overview", "context", "scope!", "requirement", "specification", "feature.", "bug", "fix", "patch,", "release", "version", "update?", "upgrade", "downgrade", "install.", "uninstall", "setup", "configure,", "customize", "personalize", "settings!", "options", "preferences", "profile.", "account", "user", "admin,", "guest", "role", "permission?", "access", "control", "security.", "privacy", "data", "information,", "knowledge", "wisdom", "intelligence!", "learning", "education", "training.", "course", "lesson", "tutorial,", "guide", "manual", "book?", "article", "blog", "forum.", "community", "support", "help,", "faq", "troubleshoot", "debug!", "solve", "resolve", "fix.", "repair", "restore", "backup,", "recover", "archive", "compress?", "decompress", "encrypt", "decrypt.", "hash", "checksum", "validate,", "verify", "authenticate", "authorize!", "grant", "revoke", "deny.", "allow", "enable", "disable,", "toggle", "switch", "activate?", "deactivate", "start", "stop.", "pause", "resume", "cancel,", "abort", "retry", "redo!", "undo", "save", "load.", "open", "close", "new,", "edit", "delete", "copy?", "cut", "paste", "select.", "all", "clear", "reset,", "submit", "send", "receive!", "download", "upload", "import.", "export", "share", "print,", "preview", "zoom", "in?", "out", "fit", "width.", "height", "actual", "size,", "fullscreen", "exit", "search!", "filter", "sort", "group.", "categorize", "tag", "label,", "mark", "favorite", "bookmark?", "pin", "hide", "show.", "collapse", "expand", "move,", "rename", "duplicate", "clone!", "merge", "split", "join.", "combine", "separate", "extract,", "insert", "remove", "replace?", "find", "replace", "goto.", "line", "column", "character,", "word", "sentence", "paragraph!", "document", "file", "folder.", "directory", "path", "url,", "uri", "urn", "protocol?", "host", "port", "query.", "fragment", "scheme", "authority,", "userinfo", "hostname", "pathname!", "search", "hash", "origin.", "protocol", "domain", "subdomain,", "top-level", "second-level", "country-code!", "generic", "reserved", "public.", "private", "local", "global,", "internal", "external", "remote!", "cloud", "on-premise", "hybrid.", "distributed", "centralized", "decentralized,", "peer-to-peer", "client-server", "front-end!", "back-end", "full-stack", "desktop.", "mobile", "web", "native,", "cross-platform", "hybrid", "responsive!", "adaptive", "fluid", "fixed.", "grid", "flexbox", "bootstrap,", "material", "design", "ui!", "ux", "interface", "experience.", "interaction", "usability", "accessibility,", "performance", "security", "scalability!", "reliability", "availability", "maintainability.", "testability", "extensibility", "flexibility,", "portability", "reusability", "modularity!", "simplicity", "consistency", "efficiency.", "robustness", "error-handling", "logging,", "monitoring", "debugging", "testing!", "deployment", "automation", "scripting.", "programming", "coding", "software,", "hardware", "firmware", "middleware!", "operating", "system", "kernel.", "shell", "command", "line,", "interface", "graphical", "user!", "interface", "api", "sdk.", "library", "framework", "tool,", "utility", "application", "program!", "service", "daemon", "process.", "thread", "concurrency", "parallelism,", "synchronization", "asynchronous", "callback!", "promise", "async", "await.", "event", "loop", "queue,", "stack", "heap", "tree!", "graph", "linked", "list.", "array", "object", "map,", "set", "iterator", "generator!", "decorator", "closure", "higher-order.", "function", "pure", "function,", "side-effect", "idempotent", "immutable!", "mutable", "state", "stateless.", "stateful", "component", "props,", "state", "lifecycle", "hook!", "context", "provider", "consumer.", "reducer", "action", "dispatch,", "store", "subscribe", "unsubscribe!", "middleware", "thunk", "saga.", "redux", "mobx", "vuex,", "angular", "react", "vue!", "jquery", "lodash", "underscore.", "moment", "date-fns", "axios,", "fetch", "websocket", "socket.io!", "graphql", "rest", "api.", "json", "xml", "yaml,", "csv", "tsv", "markdown!", "html", "css", "javascript.", "typescript", "python", "java,", "csharp", "go", "rust!", "php", "ruby", "swift.", "kotlin", "scala", "haskell,", "clojure", "lisp", "erlang!", "elixir", "perl", "bash.", "shell", "powershell", "sql,", "nosql", "mongodb", "postgresql!", "mysql", "sqlite", "redis.", "cassandra", "elasticsearch", "kafka,", "rabbit", "mq", "aws!", "azure", "gcp", "docker.", "kubernetes", "git", "github,", "gitlab", "bitbucket", "jenkins!", "travis", "ci", "circleci.", "github", "actions", "azure,", "devops", "jira", "trello!", "asana", "slack", "discord.", "zoom", "google", "meet,", "microsoft", "teams", "outlook!", "gmail", "calendar", "drive.", "docs", "sheets", "slides,", "forms", "maps", "youtube!", "twitter", "facebook", "instagram.", "linkedin", "snapchat", "tiktok,", "reddit", "pinterest", "whatsapp!", "telegram", "signal", "viber.", "wechat", "line", "skype,", "facetime", "imessage", "sms!", "email", "phone", "call.", "video", "audio", "text,", "message", "chat", "group!", "channel", "thread", "notification.", "alert", "badge", "icon,", "button", "link", "input!", "text", "area", "checkbox.", "radio", "select", "option,", "dropdown", "slider", "range!", "progress", "bar", "spinner.", "loader", "tooltip", "popover,", "modal", "dialog", "accordion!", "tabs", "carousel", "pagination.", "breadcrumb", "navbar", "sidebar,", "footer", "header", "main!", "section", "article", "aside.", "figure", "figcaption", "details,", "summary", "dialog", "menu!", "item", "list", "unordered.", "ordered", "definition", "table,", "row", "column", "cell!", "caption", "thead", "tbody.", "tfoot", "form", "fieldset,", "legend", "label", "input!", "textarea", "button", "select.", "option", "datalist", "output,", "meter", "progress", "img!", "picture", "source", "svg.", "canvas", "audio", "video,", "track", "embed", "iframe!", "object", "param", "map.", "area", "link", "meta,", "style", "script", "noscript!", "template", "slot", "abbr.", "address", "b", "bdi,", "bdo", "blockquote", "cite!", "code", "del", "dfn.", "em", "i", "ins,", "kbd", "mark", "q!", "rp", "rt", "rtc.", "ruby", "s", "samp,", "small", "span", "strong!", "sub", "sup", "time.", "u", "var", "wbr,"
            ];

            if (lengthCategory === 'random-words') {
                let generatedText = "";
                const baseWordCount = 300; 
                const targetWordCount = baseWordCount * (testDurationSelect.value / 5); 
                for (let i = 0; i < targetWordCount; i++) {
                    generatedText += randomWordList[Math.floor(Math.random() * randomWordList.length)] + " ";
                }
                return generatedText.trim();
            } else if (lengthCategory === 'short') {
                return shortStories[Math.floor(Math.random() * shortStories.length)];
            } else if (lengthCategory === 'long') {
                return longStories[Math.floor(Math.random() * longStories.length)];
            } else { // 'medium' or default AI story fallback
                return "The sun dipped below the horizon, painting the sky in hues of orange and purple. A lone bird soared across the fading light, its wings catching the last rays. Below, the city lights began to twinkle, promising a night of bustling activity. A gentle breeze carried the scent of blooming jasmine through the open window. It was a perfect evening to reflect on the day's events and anticipate the quiet hours ahead. The world felt at peace, a symphony of subtle changes unfolding as darkness embraced the landscape, bringing with it the promise of a new dawn and fresh opportunities. Every moment held a quiet beauty, a fleeting perfection that made the heart sing with gratitude for its simple existence.";
            }
        }
        // --- END MOCK AI GENERATION ---

        // DOM Elements
        const mainContent = document.getElementById('main-content');
        const testArea = document.getElementById('test-area');
        const typingInput = document.getElementById('typing-input');
        const wpmDisplay = document.getElementById('wpm');
        const accuracyDisplay = document.getElementById('accuracy');
        const errorsDisplay = document.getElementById('errors');
        const cpmDisplay = document.getElementById('cpm'); 
        const kdphDisplay = document.getElementById('kdph'); // New KDPH display
        const countdownDisplay = document.getElementById('countdown');
        const restartButton = document.getElementById('restart-button');
        const settingsButton = document.getElementById('settings-button');
        const resultModal = document.getElementById('result-modal');
        const finalWpmDisplay = document.getElementById('final-wpm');
        const finalAccuracyDisplay = document.getElementById('final-accuracy');
        const finalErrorsDisplay = document.getElementById('final-errors');
        const rawWpmDisplay = document.getElementById('raw-wpm');
        const finalCpmDisplay = document.getElementById('final-cpm'); 
        const finalKdphDisplay = document.getElementById('final-kdph'); // New Final KDPH display
        const modalRestartButton = document.getElementById('modal-restart-button');
        const modalSettingsButton = document.getElementById('modal-settings-button');

        // Settings Overlay Elements
        const settingsOverlay = document.getElementById('settings-overlay');
        const testDurationSelect = document.getElementById('test-duration');
        const targetWpmInput = document.getElementById('target-wpm');
        const targetAccuracyInput = document.getElementById('target-accuracy');
        const storyTypeSelect = document.getElementById('story-type');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const skipSettingsButton = document.getElementById('skip-settings-button');
        const wpmTargetStatus = document.getElementById('wpm-target-status');
        const accuracyTargetStatus = document.getElementById('accuracy-target-status');

        // New Custom Story Elements
        const customStoryArea = document.getElementById('custom-story-area');
        const customStoryTextarea = document.getElementById('custom-story-textarea');
        const addStoryLinkButton = document.getElementById('add-story-link-button');

        // Detailed Error Elements
        const errIncorrectChars = document.getElementById('err-incorrect-chars');
        const errMissedChars = document.getElementById('err-missed-chars');
        const errExtraChars = document.getElementById('err-extra-chars');
        const errSkippedWords = document.getElementById('err-skipped-words');
        const errExtraWords = document.getElementById('err-extra-words');
        const errIncorrectEnter = document.getElementById('err-incorrect-enter');
        const errIncorrectSpace = document.getElementById('err-incorrect-space');


        // Global Variables
        let testWords = []; // This array will hold the expected words and '\n' markers
        let wordIndex = 0;
        let charIndex = 0; // Current character index within the current word
        let startTime;
        let timerInterval;
        let defaultTestDuration = 5 * 60; // Default 5 minutes in seconds
        let timeLeft = defaultTestDuration;
        
        let correctChars = 0; // Correct characters typed (for WPM/CPM/KDPH)
        let totalTypedChars = 0; // All characters typed by user (correct + incorrect + extra)
        let totalExpectedCharsTyped = 0; // Characters from the expected text that were correctly or incorrectly attempted

        // Detailed Error Counts
        let errors = {
            incorrectChars: 0, // Mismatched characters
            missedChars: 0,    // Characters in expected word not typed by user
            extraChars: 0,     // Characters typed by user beyond expected word length
            skippedWords: 0,   // Words skipped by user
            extraWords: 0,     // User typed a word not in expected text (e.g., hit space before expected word)
            incorrectEnter: 0, // User pressed Enter when not expected newline
            incorrectSpace: 0  // User pressed Space when expected newline
        };

        let userTargetWPM = null;
        let userTargetAccuracy = null;
        let currentStoryType = 'random-words'; 
        let customStoryText = ''; 
        let isTestRunning = false;


        // Utility to format time
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        async function generateAndRenderTestWords() {
            testWords = []; 
            testArea.innerHTML = ''; 

            let textToType = "";

            if (currentStoryType === 'ai-story') {
                let lengthCategory = 'medium'; 
                const durationMinutes = parseInt(testDurationSelect.value);
                if (durationMinutes <= 2) {
                    lengthCategory = 'short';
                } else if (durationMinutes >= 10) {
                    lengthCategory = 'long';
                }
                textToType = await fetchAIGeneratedStory(lengthCategory);
            } else if (currentStoryType === 'user-custom') {
                textToType = customStoryText.trim();
                if (textToType === "") {
                    alert("Please paste your custom story in the text area or select another story type.");
                    settingsOverlay.classList.add('show');
                    mainContent.classList.add('content-hidden');
                    return false; 
                }
            } else { 
                textToType = await fetchAIGeneratedStory('random-words');
            }

            const paragraphs = textToType.split(/\r?\n/); 

            paragraphs.forEach((paragraphText, paraIdx) => {
                const paragraphDiv = document.createElement('div');
                paragraphDiv.classList.add('paragraph');

                // Split words in a paragraph by one or more spaces
                // Use a regex to also capture trailing spaces for words, but split by space to get words
                const wordsWithSpaces = paragraphText.match(/\S+\s*|\s+/g) || []; // Matches words and spaces
                
                wordsWithSpaces.forEach((item, itemIdxInPara) => {
                    if (item.trim() === '') { // It's just a space or multiple spaces
                        // We don't add standalone spaces to testWords, space is handled by logic between words
                        // The visual word spans will naturally handle spacing.
                    } else { // It's a word (potentially with trailing spaces)
                        // Treat the actual word (without trailing spaces) as the "expected" word
                        const actualWord = item.trim(); 
                        testWords.push(actualWord); 

                        const wordSpan = document.createElement('span');
                        wordSpan.classList.add('word');
                        actualWord.split('').forEach(char => {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = char;
                            charSpan.classList.add('untyped');
                            wordSpan.appendChild(charSpan);
                        });
                        
                        // Add trailing spaces as untyped characters to the word span for accurate visual representation
                        const trailingSpaces = item.substring(actualWord.length);
                        for (let i = 0; i < trailingSpaces.length; i++) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = trailingSpaces[i];
                            charSpan.classList.add('untyped');
                            wordSpan.appendChild(charSpan);
                        }
                        
                        paragraphDiv.appendChild(wordSpan);
                    }
                });

                if (paraIdx < paragraphs.length -1) { 
                    const newlineMarker = document.createElement('span');
                    newlineMarker.classList.add('newline-marker');
                    paragraphDiv.appendChild(newlineMarker);
                    
                    testWords.push('\n'); // Special indicator for newline in testWords array
                }
                
                testArea.appendChild(paragraphDiv);
            });
            
            highlightCurrentWord();
            adjustTestAreaScroll();
            return true; 
        }

        function getDomElementForTestItem(targetIndex) {
            let currentTraversalIndex = 0;
            const paragraphs = testArea.querySelectorAll('.paragraph');

            for (let i = 0; i < paragraphs.length; i++) {
                const paragraphDiv = paragraphs[i];
                const children = Array.from(paragraphDiv.children); 

                for (let j = 0; j < children.length; j++) {
                    const child = children[j];
                    if (currentTraversalIndex === targetIndex) {
                        return child;
                    }
                    currentTraversalIndex++;
                }
            }
            return null; 
        }

        function highlightCurrentWord() {
            testArea.querySelectorAll('.word').forEach(span => {
                span.classList.remove('current-word');
            });
            testArea.querySelectorAll('.newline-marker').forEach(marker => {
                marker.classList.remove('current-newline-marker');
            });


            if (wordIndex >= testWords.length) {
                // If all words are typed, still ensure test area is scrolled to the end if necessary.
                adjustTestAreaScroll(); 
                return;
            }

            const currentItem = testWords[wordIndex];
            const currentDomElement = getDomElementForTestItem(wordIndex);

            if (currentItem === '\n') {
                if (currentDomElement && currentDomElement.classList.contains('newline-marker')) {
                    currentDomElement.classList.add('current-newline-marker');
                    adjustTestAreaScroll();
                }
            } else if (currentDomElement && currentDomElement.classList.contains('word')) {
                currentDomElement.classList.add('current-word');
                adjustTestAreaScroll();
            }
        }

        // Function to automatically scroll the test area
        function adjustTestAreaScroll() {
            const currentDomElement = getDomElementForTestItem(wordIndex);
            if (!currentDomElement) return;

            const testAreaRect = testArea.getBoundingClientRect();
            const targetRect = currentDomElement.getBoundingClientRect();

            // Calculate vertical scroll
            // If the target element's bottom is below the test area's visible bottom
            if (targetRect.bottom > testAreaRect.bottom) {
                testArea.scrollTop += (targetRect.bottom - testAreaRect.bottom) + 10; // Scroll down by diff + a little buffer
            }
            // If the target element's top is above the test area's visible top
            else if (targetRect.top < testAreaRect.top) {
                testArea.scrollTop -= (testAreaRect.top - targetRect.top) + 10; // Scroll up by diff + a little buffer
            }
        }

        function updateStats() {
            const timeElapsed = (defaultTestDuration - timeLeft);
            if (!isTestRunning || timeElapsed === 0) {
                wpmDisplay.textContent = 0;
                accuracyDisplay.textContent = 0;
                errorsDisplay.textContent = errors.incorrectChars + errors.missedChars + errors.extraChars + errors.skippedWords + errors.extraWords + errors.incorrectEnter + errors.incorrectSpace;
                cpmDisplay.textContent = 0;
                kdphDisplay.textContent = 0;
                return; 
            }

            const minutesElapsed = timeElapsed / 60;
            const hoursElapsed = timeElapsed / 3600;

            // WPM calculation: (Correct Words / Time in Minutes)
            // A "word" is often defined as 5 characters including spaces.
            const grossWPM = (correctChars / 5) / minutesElapsed;
            
            // Calculate penalty:
            // For Govt Jobs, penalties can vary greatly. A common rule is:
            // 1 full mistake = 1 word penalty. A full mistake can be 5 half mistakes.
            // Here, we'll simplify and count every incorrect key depression as 1/5th of a word penalty.
            // Or, more accurately, every error (incorrect char, missed char, extra char, etc.) contributes to deduction.
            // Let's use a simple common rule for now: 5 characters (including space) per word.
            // Errors: incorrectChars + missedChars + extraChars + (skippedWords * 5) + (extraWords * 5) + (incorrectEnter * 1) + (incorrectSpace * 1)
            // A very common penalty rule: 5 incorrect characters = 1 WPM deduction.
            // Let's simplify and make all errors count towards `incorrectChars` for accuracy, and `WPM` is based on net correct characters.

            // The net WPM is based on (correct keystrokes - errors) / 5 / time
            // For now, let's keep it based on `correctChars` and `typedCharsOverall` for WPM/Accuracy
            // and detail error types in modal.
            
            // Raw WPM: All attempted keystrokes / 5 / minutes
            const rawWPM = (totalTypedChars / 5) / minutesElapsed;
            
            // Net WPM: (Correct Characters - Total Errors) / 5 / minutes
            // This is a common way to calculate net WPM in some tests.
            const totalErrors = errors.incorrectChars + errors.missedChars + errors.extraChars + 
                              (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace;

            const netWPM = ((correctChars - totalErrors) / 5) / minutesElapsed;
            wpmDisplay.textContent = Math.max(0, Math.round(netWPM)); // WPM can't be negative

            // CPM calculation: Total Correct Characters / (Time in Minutes)
            const currentCPM = correctChars / minutesElapsed;
            cpmDisplay.textContent = isNaN(currentCPM) ? 0 : Math.round(currentCPM);

            // KDPH calculation: (Total Correct Key Strokes / Time in Hours)
            // Each correct char, space, and correct enter is a key stroke.
            const currentKDPH = (correctChars / hoursElapsed);
            kdphDisplay.textContent = isNaN(currentKDPH) ? 0 : Math.round(currentKDPH);


            // Accuracy calculation: (Correctly typed chars / Total chars attempted) * 100
            // totalExpectedCharsTyped is the sum of characters from expected text that user has either correctly typed or incorrectly attempted to type
            // totalTypedChars is all chars the user typed, including extra chars beyond expected word length.
            const currentAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
            accuracyDisplay.textContent = isNaN(currentAccuracy) ? 0 : currentAccuracy;
            
            // Total Errors for display
            errorsDisplay.textContent = totalErrors;
        }

        function startTimer() {
            startTime = Date.now();
            isTestRunning = true;
            timerInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = formatTime(timeLeft);
                updateStats();

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endTest();
                }
            }, 1000);
        }

        function endTest() {
            isTestRunning = false;
            typingInput.disabled = true;
            typingInput.value = '';
            clearInterval(timerInterval);
            
            // Final calculation for remaining untyped words
            for (let i = wordIndex; i < testWords.length; i++) {
                if (testWords[i] !== '\n') {
                    errors.skippedWords++;
                } else {
                    // if a newline was expected but not typed, count as a missed char or similar
                    errors.missedChars++; 
                }
            }

            updateStats(); // Final update to ensure all metrics are current

            const timeElapsed = (defaultTestDuration - timeLeft);
            const finalMinutesElapsed = timeElapsed / 60;
            const finalHoursElapsed = timeElapsed / 3600;

            // Handle potential division by zero if test ended immediately for some reason
            if (finalMinutesElapsed === 0) { // If timeElapsed is 0, test ended instantly
                 finalWpmDisplay.textContent = 0;
                 finalAccuracyDisplay.textContent = 0;
                 finalErrorsDisplay.textContent = 0;
                 rawWpmDisplay.textContent = 0;
                 finalCpmDisplay.textContent = 0;
                 finalKdphDisplay.textContent = 0;
            } else {
                // Total errors for penalty in Net WPM calculation
                const totalCalculatedErrors = errors.incorrectChars + errors.missedChars + errors.extraChars + 
                                            (errors.skippedWords * 5) + (errors.extraWords * 5) + errors.incorrectEnter + errors.incorrectSpace;

                // Net WPM: (Correct Characters - Total Errors) / 5 / minutes
                const finalNetWPM = Math.max(0, ((correctChars - totalCalculatedErrors) / 5) / finalMinutesElapsed);
                finalWpmDisplay.textContent = Math.round(finalNetWPM);

                const finalRawWPM = (totalTypedChars / 5) / finalMinutesElapsed; // All chars user typed / 5 / minutes
                rawWpmDisplay.textContent = Math.round(finalRawWPM);
                
                const finalAccuracy = totalTypedChars === 0 ? 0 : Math.round((correctChars / totalTypedChars) * 100);
                finalAccuracyDisplay.textContent = finalAccuracy;

                const finalCPM = correctChars / finalMinutesElapsed;
                finalCpmDisplay.textContent = Math.round(finalCPM);

                const finalKDPH = correctChars / finalHoursElapsed;
                finalKdphDisplay.textContent = Math.round(finalKDPH);

                finalErrorsDisplay.textContent = totalCalculatedErrors; // Sum of all error categories
            }

            // Set detailed error stats in modal
            errIncorrectChars.textContent = errors.incorrectChars;
            errMissedChars.textContent = errors.missedChars;
            errExtraChars.textContent = errors.extraChars;
            errSkippedWords.textContent = errors.skippedWords;
            errExtraWords.textContent = errors.extraWords;
            errIncorrectEnter.textContent = errors.incorrectEnter;
            errIncorrectSpace.textContent = errors.incorrectSpace;


            // Add color to final results
            finalWpmDisplay.className = 'result-value-green';
            finalAccuracyDisplay.className = 'result-value-green';
            finalErrorsDisplay.className = 'result-value-red'; 
            rawWpmDisplay.className = 'result-value-purple';
            finalCpmDisplay.className = 'result-value-orange';
            finalKdphDisplay.className = 'result-value-kdph';


            // Check and update target status
            if (userTargetWPM !== null && !isNaN(userTargetWPM)) {
                if (parseFloat(finalWpmDisplay.textContent) >= userTargetWPM) {
                    wpmTargetStatus.querySelector('p').textContent = `Met (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    wpmTargetStatus.querySelector('p').textContent = `Missed (${userTargetWPM} WPM)`;
                    wpmTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                wpmTargetStatus.querySelector('p').textContent = 'N/A';
                wpmTargetStatus.querySelector('p').className = 'status-neutral';
            }

            if (userTargetAccuracy !== null && !isNaN(userTargetAccuracy)) {
                if (parseFloat(finalAccuracyDisplay.textContent) >= userTargetAccuracy) {
                    accuracyTargetStatus.querySelector('p').textContent = `Met (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-met';
                } else {
                    accuracyTargetStatus.querySelector('p').textContent = `Missed (${userTargetAccuracy}%)`;
                    accuracyTargetStatus.querySelector('p').className = 'status-not-met';
                }
            } else {
                accuracyTargetStatus.querySelector('p').textContent = 'N/A';
                accuracyTargetStatus.querySelector('p').className = 'status-neutral';
            }

            resultModal.classList.add('show');
            restartButton.disabled = false;
            settingsButton.disabled = false;
        }

        async function initializeTest(duration, targetWPM, targetAccuracy, storyType, customText = '') {
            clearInterval(timerInterval);
            defaultTestDuration = duration * 60; 
            timeLeft = defaultTestDuration;
            countdownDisplay.textContent = formatTime(timeLeft);
            wordIndex = 0;
            charIndex = 0; 
            correctChars = 0;
            totalTypedChars = 0;
            totalExpectedCharsTyped = 0;
            errors = { // Reset all error counts
                incorrectChars: 0,
                missedChars: 0,
                extraChars: 0,
                skippedWords: 0,
                extraWords: 0,
                incorrectEnter: 0,
                incorrectSpace: 0
            };

            typingInput.value = '';
            typingInput.disabled = false;
            startTime = null; 
            isTestRunning = false;
            
            userTargetWPM = targetWPM ? parseInt(targetWPM) : null;
            userTargetAccuracy = targetAccuracy ? parseInt(targetAccuracy) : null;
            currentStoryType = storyType;
            customStoryText = customText; 

            wpmDisplay.textContent = '0';
            accuracyDisplay.textContent = '0';
            errorsDisplay.textContent = '0';
            cpmDisplay.textContent = '0'; 
            kdphDisplay.textContent = '0'; // Reset KDPH display

            restartButton.disabled = false; 
            settingsButton.disabled = false;
            
            const generationSuccess = await generateAndRenderTestWords();
            if (!generationSuccess) {
                return;
            }

            typingInput.focus();
            resultModal.classList.remove('show');
            settingsOverlay.classList.remove('show'); 
            mainContent.classList.remove('content-hidden'); 
        }


        // Event Listeners

        typingInput.addEventListener('input', (e) => {
            if (!isTestRunning && startTime === null) {
                startTimer(); 
            }
            
            const currentExpectedItem = testWords[wordIndex];
            const typedText = e.target.value;

            // If we are currently at a newline marker, prevent typing anything
            if (currentExpectedItem === '\n') {
                typingInput.value = ''; 
                return; 
            }

            const currentWordExpected = currentExpectedItem; 
            const currentWordSpan = getDomElementForTestItem(wordIndex); 

            if (!currentWordSpan || !currentWordSpan.classList.contains('word')) { 
                return;
            }

            const charSpans = Array.from(currentWordSpan.querySelectorAll('span')); 

            // Reset all spans in current word to untyped and remove correctness classes
            charSpans.forEach(span => {
                span.classList.remove('correct', 'incorrect', 'extra');
                span.classList.add('untyped');
                span.style.display = 'inline'; 
            });

            // Update char rendering within the current word
            // Calculate real-time feedback and update `correctChars` and `totalTypedChars` for live stats
            // We'll re-evaluate `incorrectChars` at word completion (space/enter) for accuracy penalty.
            let currentWordCorrectChars = 0;
            let currentWordTypedChars = 0;

            // Handle expected characters
            for (let i = 0; i < currentWordExpected.length; i++) {
                const charExpected = currentWordExpected[i];
                const typedChar = typedText[i];
                const charSpan = charSpans[i];

                if (charSpan) { // Character span exists for expected character
                    if (typedChar === undefined) {
                        charSpan.classList.add('untyped');
                    } else if (typedChar === charExpected) { // Case-sensitive comparison
                        charSpan.classList.add('correct');
                        currentWordCorrectChars++;
                    } else {
                        charSpan.classList.add('incorrect');
                    }
                }
            }

            // Handle extra characters typed (beyond the current word's length)
            // First, remove any existing extra spans
            currentWordSpan.querySelectorAll('.extra').forEach(el => el.remove());

            // Then, create and add new extra chars
            if (typedText.length > currentWordExpected.length) {
                for (let i = currentWordExpected.length; i < typedText.length; i++) {
                    const extraSpan = document.createElement('span');
                    extraSpan.textContent = typedText[i];
                    extraSpan.classList.add('extra');
                    currentWordSpan.appendChild(extraSpan);
                }
            }
            
            // This `charIndex` is just for visual feedback of typed characters within the current word
            charIndex = typedText.length;
            
            updateStats();
        });


        // Keydown event for Space and Enter
        typingInput.addEventListener('keydown', (e) => {
            if (!isTestRunning && startTime === null) {
                startTimer();
            }

            const currentExpectedItem = testWords[wordIndex];
            const typedText = typingInput.value;

            if (e.key === ' ') { 
                e.preventDefault(); 

                // If currently at a newline marker, hitting space is an error
                if (currentExpectedItem === '\n') {
                    errors.incorrectSpace++;
                    totalTypedChars++; // Count the incorrect space as a typed char
                    typingInput.value = ''; 
                    updateStats();
                    return; 
                }
                
                const currentWordExpected = currentExpectedItem;
                let wordTyped = typedText; // Do not trim here, space matters for final word comparison logic
                
                // Compare word for accurate error calculation at word completion
                let wordCorrectChars = 0;
                
                for (let i = 0; i < Math.max(currentWordExpected.length, wordTyped.length); i++) {
                    const expectedChar = currentWordExpected[i];
                    const typedChar = wordTyped[i];

                    if (typedChar === undefined) { // Missed character
                        errors.missedChars++;
                    } else if (expectedChar === undefined) { // Extra character typed by user
                        errors.extraChars++;
                    } else if (typedChar !== expectedChar) { // Incorrect character
                        errors.incorrectChars++;
                    } else { // Correct character
                        wordCorrectChars++;
                    }
                }

                correctChars += wordCorrectChars;
                totalTypedChars += wordTyped.length; // Characters actually typed by user for this word
                totalTypedChars++; // Account for the space itself

                totalExpectedCharsTyped += currentWordExpected.length; // Length of the expected word

                wordIndex++; 
                typingInput.value = ''; 
                charIndex = 0; // Reset charIndex for next word
                highlightCurrentWord(); 

                if (wordIndex >= testWords.length) { 
                    endTest();
                }
                updateStats();

            } else if (e.key === 'Enter') { 
                e.preventDefault(); 

                if (currentExpectedItem === '\n') {
                    // Check if any text was typed before hitting Enter for a newline
                    if (typedText.length > 0) {
                        errors.incorrectChars += typedText.length; // Count these as incorrect characters
                        totalTypedChars += typedText.length;
                    }
                    
                    correctChars++; // Correctly handled newline counts as one correct stroke
                    totalTypedChars++; // Count the Enter key as one typed character
                    totalExpectedCharsTyped++; // Count the expected newline as one expected char

                    wordIndex++; 
                    typingInput.value = ''; 
                    charIndex = 0; 
                    highlightCurrentWord(); 

                    if (wordIndex >= testWords.length) {
                        endTest();
                    }
                } else {
                    // If Enter is pressed but we are NOT expecting a newline, it's an error
                    errors.incorrectEnter++; 
                    totalTypedChars++; // Count this incorrect Enter as a typed char
                }
                updateStats();
            } else if (e.key === 'Backspace') {
                // Backspace logic is primarily handled by the 'input' event for visual feedback.
                // We don't adjust error counts on backspace directly, as those are calculated
                // when a word is completed (space/enter).
                // If typedText length is 0, we're at the start of the current word
                if (charIndex > 0) {
                    charIndex--;
                }
                // No need to adjust `correctChars` or `totalTypedChars` here, as the `input` event
                // will re-evaluate the current word's state based on the new `typingInput.value`.
            }
        });


        restartButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            resultModal.classList.remove('show'); 
            mainContent.classList.add('content-hidden'); 
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; 
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        settingsButton.addEventListener('click', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); 
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; 
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        saveSettingsButton.addEventListener('click', async () => {
            const duration = parseInt(testDurationSelect.value);
            const targetWPM = targetWpmInput.value;
            const targetAccuracy = targetAccuracyInput.value;
            const storyType = storyTypeSelect.value;
            let storyContent = '';

            if (storyType === 'user-custom') {
                storyContent = customStoryTextarea.value.trim();
            }
            await initializeTest(duration, targetWPM, targetAccuracy, storyType, storyContent);
        });

        skipSettingsButton.addEventListener('click', async () => {
            await initializeTest(5, null, null, 'random-words'); 
        });

        modalRestartButton.addEventListener('click', async () => {
            await initializeTest(defaultTestDuration / 60, userTargetWPM, userTargetAccuracy, currentStoryType, customStoryText); 
        });

        modalSettingsButton.addEventListener('click', () => {
            resultModal.classList.remove('show');
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden'); 
            // Reset inputs in settings modal to current values
            testDurationSelect.value = defaultTestDuration / 60;
            targetWpmInput.value = userTargetWPM || '';
            targetAccuracyInput.value = userTargetAccuracy || '';
            storyTypeSelect.value = currentStoryType;
            if (currentStoryType === 'user-custom') {
                customStoryArea.style.display = 'block';
                customStoryTextarea.value = customStoryText; 
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for Story Type dropdown to show/hide custom story area
        storyTypeSelect.addEventListener('change', () => {
            if (storyTypeSelect.value === 'user-custom') {
                customStoryArea.style.display = 'block';
            } else {
                customStoryArea.style.display = 'none';
            }
        });

        // Event listener for "Add Story from Reedsy" button
        addStoryLinkButton.addEventListener('click', () => {
            window.open('https://blog.reedsy.com/short-stories/', '_blank');
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            settingsOverlay.classList.add('show');
            mainContent.classList.add('content-hidden');
            countdownDisplay.textContent = formatTime(defaultTestDuration); 
            customStoryArea.style.display = 'none';
        });

    </script>
</body>
</html>
